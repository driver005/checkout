/* tslint:disable */
/* eslint-disable */
/**
 * Fiber Swagger Example API
 * This is a sample server server.
 *
 * The version of the OpenAPI document: 2.0
 * Contact: support@swagger.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccountAccount
 */
export interface AccountAccount {
    /**
     * 
     * @type {string}
     * @memberof AccountAccount
     */
    'business_profile'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountAccount
     */
    'created_at'?: string;
    /**
     * 
     * @type {DatabaseDeletedAt}
     * @memberof AccountAccount
     */
    'deleted_at'?: DatabaseDeletedAt;
    /**
     * 
     * @type {string}
     * @memberof AccountAccount
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AccountAccount
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof AccountAccount
     */
    'metadata'?: object;
    /**
     * 
     * @type {string}
     * @memberof AccountAccount
     */
    'object'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountAccount
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface AttemptSetupAttempt
 */
export interface AttemptSetupAttempt {
    /**
     * 
     * @type {boolean}
     * @memberof AttemptSetupAttempt
     */
    'attach_to_self'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AttemptSetupAttempt
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof AttemptSetupAttempt
     */
    'customer'?: string;
    /**
     * 
     * @type {DatabaseDeletedAt}
     * @memberof AttemptSetupAttempt
     */
    'deleted_at'?: DatabaseDeletedAt;
    /**
     * 
     * @type {Array<string>}
     * @memberof AttemptSetupAttempt
     */
    'flow_directions'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof AttemptSetupAttempt
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AttemptSetupAttempt
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof AttemptSetupAttempt
     */
    'metadata'?: object;
    /**
     * 
     * @type {string}
     * @memberof AttemptSetupAttempt
     */
    'object'?: string;
    /**
     * 
     * @type {string}
     * @memberof AttemptSetupAttempt
     */
    'payment_method'?: string;
    /**
     * 
     * @type {string}
     * @memberof AttemptSetupAttempt
     */
    'payment_method_details'?: string;
    /**
     * 
     * @type {string}
     * @memberof AttemptSetupAttempt
     */
    'setup_error'?: string;
    /**
     * 
     * @type {string}
     * @memberof AttemptSetupAttempt
     */
    'setup_intent'?: string;
    /**
     * 
     * @type {AttemptStatus}
     * @memberof AttemptSetupAttempt
     */
    'status'?: AttemptStatus;
    /**
     * 
     * @type {string}
     * @memberof AttemptSetupAttempt
     */
    'updated_at'?: string;
    /**
     * 
     * @type {AttemptUsage}
     * @memberof AttemptSetupAttempt
     */
    'usage'?: AttemptUsage;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const AttemptStatus = {
    StatusRequiresConfirmation: 'requires_confirmation',
    StatusRequiresAction: 'requires_action',
    StatusProcessing: 'processing',
    StatusSucceeded: 'succeeded',
    StatusFailed: 'failed',
    StatusAbandoned: 'abandoned'
} as const;

export type AttemptStatus = typeof AttemptStatus[keyof typeof AttemptStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const AttemptUsage = {
    UsageOffSession: 'off_session',
    UsageOnSession: 'on_session'
} as const;

export type AttemptUsage = typeof AttemptUsage[keyof typeof AttemptUsage];


/**
 * 
 * @export
 * @interface BalanceBalance
 */
export interface BalanceBalance {
    /**
     * Funds that are available to be transferred or paid out, whether automatically by Stripe or explicitly via the [Transfers API](https://stripe.com/docs/api#transfers) or [Payouts API](https://stripe.com/docs/api#payouts). The available balance for each currency and payment type can be found in the `source_types` property.
     * @type {Array<string>}
     * @memberof BalanceBalance
     */
    'available'?: Array<string>;
    /**
     * Funds held due to negative balances on connected Custom accounts. The connect reserve balance for each currency and payment type can be found in the `source_types` property.
     * @type {Array<string>}
     * @memberof BalanceBalance
     */
    'connect_reserved'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof BalanceBalance
     */
    'created_at'?: string;
    /**
     * 
     * @type {DatabaseDeletedAt}
     * @memberof BalanceBalance
     */
    'deleted_at'?: DatabaseDeletedAt;
    /**
     * 
     * @type {string}
     * @memberof BalanceBalance
     */
    'id'?: string;
    /**
     * Funds that can be paid out using Instant Payouts.
     * @type {Array<string>}
     * @memberof BalanceBalance
     */
    'instant_available'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof BalanceBalance
     */
    'issuing'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BalanceBalance
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof BalanceBalance
     */
    'metadata'?: object;
    /**
     * 
     * @type {string}
     * @memberof BalanceBalance
     */
    'object'?: string;
    /**
     * Funds that are not yet available in the balance, due to the 7-day rolling pay cycle. The pending balance for each currency, and for each payment type, can be found in the `source_types` property.
     * @type {Array<string>}
     * @memberof BalanceBalance
     */
    'pending'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof BalanceBalance
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface BalanceBalanceTransaction
 */
export interface BalanceBalanceTransaction {
    /**
     * Gross amount of the transaction, in %s.
     * @type {number}
     * @memberof BalanceBalanceTransaction
     */
    'amount'?: number;
    /**
     * The date the transaction\'s net funds will become available in the Stripe balance.
     * @type {number}
     * @memberof BalanceBalanceTransaction
     */
    'available_on'?: number;
    /**
     * 
     * @type {string}
     * @memberof BalanceBalanceTransaction
     */
    'created_at'?: string;
    /**
     * Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
     * @type {string}
     * @memberof BalanceBalanceTransaction
     */
    'currency'?: string;
    /**
     * 
     * @type {DatabaseDeletedAt}
     * @memberof BalanceBalanceTransaction
     */
    'deleted_at'?: DatabaseDeletedAt;
    /**
     * An arbitrary string attached to the object. Often useful for displaying to users.
     * @type {string}
     * @memberof BalanceBalanceTransaction
     */
    'description'?: string;
    /**
     * The exchange rate used, if applicable, for this transaction. Specifically, if money was converted from currency A to currency B, then the `amount` in currency A, times `exchange_rate`, would be the `amount` in currency B. For example, suppose you charged a customer 10.00 EUR. Then the PaymentIntent\'s `amount` would be `1000` and `currency` would be `eur`. Suppose this was converted into 12.34 USD in your Stripe account. Then the BalanceTransaction\'s `amount` would be `1234`, `currency` would be `usd`, and `exchange_rate` would be `1.234`.
     * @type {number}
     * @memberof BalanceBalanceTransaction
     */
    'exchange_rate'?: number;
    /**
     * Fees (in %s) paid for this transaction.
     * @type {number}
     * @memberof BalanceBalanceTransaction
     */
    'fee'?: number;
    /**
     * Detailed breakdown of fees (in %s) paid for this transaction.
     * @type {Array<string>}
     * @memberof BalanceBalanceTransaction
     */
    'fee_details'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof BalanceBalanceTransaction
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BalanceBalanceTransaction
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof BalanceBalanceTransaction
     */
    'metadata'?: object;
    /**
     * Net amount of the transaction, in %s.
     * @type {number}
     * @memberof BalanceBalanceTransaction
     */
    'net'?: number;
    /**
     * 
     * @type {string}
     * @memberof BalanceBalanceTransaction
     */
    'object'?: string;
    /**
     * [Learn more](https://stripe.com/docs/reports/reporting-categories) about how reporting categories can help you understand balance transactions from an accounting perspective.
     * @type {string}
     * @memberof BalanceBalanceTransaction
     */
    'reporting_category'?: string;
    /**
     * 
     * @type {string}
     * @memberof BalanceBalanceTransaction
     */
    'source'?: string;
    /**
     * If the transaction\'s net funds are available in the Stripe balance yet. Either `available` or `pending`.
     * @type {BalanceStatus}
     * @memberof BalanceBalanceTransaction
     */
    'status'?: BalanceStatus;
    /**
     * Transaction type: `adjustment`, `advance`, `advance_funding`, `anticipation_repayment`, `application_fee`, `application_fee_refund`, `charge`, `connect_collection_transfer`, `contribution`, `issuing_authorization_hold`, `issuing_authorization_release`, `issuing_dispute`, `issuing_transaction`, `payment`, `payment_failure_refund`, `payment_refund`, `payout`, `payout_cancel`, `payout_failure`, `refund`, `refund_failure`, `reserve_transaction`, `reserved_funds`, `stripe_fee`, `stripe_fx_fee`, `tax_fee`, `topup`, `topup_reversal`, `transfer`, `transfer_cancel`, `transfer_failure`, or `transfer_refund`. [Learn more](https://stripe.com/docs/reports/balance-transaction-types) about balance transaction types and what they represent. If you are looking to classify transactions for accounting purposes, you might want to consider `reporting_category` instead.
     * @type {BalanceType}
     * @memberof BalanceBalanceTransaction
     */
    'type'?: BalanceType;
    /**
     * 
     * @type {string}
     * @memberof BalanceBalanceTransaction
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const BalanceStatus = {
    StatusAvailable: 'available',
    StatusPending: 'pending'
} as const;

export type BalanceStatus = typeof BalanceStatus[keyof typeof BalanceStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const BalanceType = {
    TypeAdjustment: 'adjustment',
    TypeAdvance: 'advance',
    TypeAdvanceFunding: 'advance_funding',
    TypeAnticipationRepayment: 'anticipation_repayment',
    TypeApplicationFee: 'application_fee',
    TypeApplicationFeeRefund: 'application_fee_refund',
    TypeCharge: 'charge',
    TypeConnectCollectionTransfer: 'connect_collection_transfer',
    TypeContribution: 'contribution',
    TypeIssuingAuthorizationHold: 'issuing_authorization_hold',
    TypeIssuingAuthorizationRelease: 'issuing_authorization_release',
    TypeIssuingDispute: 'issuing_dispute',
    TypeIssuingTransaction: 'issuing_transaction',
    TypePayment: 'payment',
    TypePaymentFailureRefund: 'payment_failure_refund',
    TypePaymentRefund: 'payment_refund',
    TypePayout: 'payout',
    TypePayoutCancel: 'payout_cancel',
    TypePayoutFailure: 'payout_failure',
    TypeRefund: 'refund',
    TypeRefundFailure: 'refund_failure',
    TypeReserveTransaction: 'reserve_transaction',
    TypeReservedFunds: 'reserved_funds',
    TypeReportingCategory: 'reporting_category',
    TypeStripeFee: 'stripe_fee',
    TypeStripeFxFee: 'stripe_fx_fee',
    TypeTaxFee: 'tax_fee',
    TypeTopup: 'topup',
    TypeTopupReversal: 'topup_reversal',
    TypeTransfer: 'transfer',
    TypeTransferCancel: 'transfer_cancel',
    TypeTransferFailure: 'transfer_failure',
    TypeTransferRefund: 'transfer_refund'
} as const;

export type BalanceType = typeof BalanceType[keyof typeof BalanceType];


/**
 * 
 * @export
 * @enum {string}
 */

export const BankAccountHolderType = {
    AccountHolderTypeIndividual: 'individual',
    AccountHolderTypeCompany: 'company'
} as const;

export type BankAccountHolderType = typeof BankAccountHolderType[keyof typeof BankAccountHolderType];


/**
 * 
 * @export
 * @enum {string}
 */

export const BankAccountType = {
    AccountTypeChecking: 'checking',
    AccountTypeSavings: 'savings',
    AccountTypeFutsu: 'futsu',
    AccountTypeToza: 'toza'
} as const;

export type BankAccountType = typeof BankAccountType[keyof typeof BankAccountType];


/**
 * 
 * @export
 * @interface BankBankAccount
 */
export interface BankBankAccount {
    /**
     * 
     * @type {AccountAccount}
     * @memberof BankBankAccount
     */
    'account'?: AccountAccount;
    /**
     * 
     * @type {string}
     * @memberof BankBankAccount
     */
    'account_holder_name'?: string;
    /**
     * 
     * @type {BankAccountHolderType}
     * @memberof BankBankAccount
     */
    'account_holder_type'?: BankAccountHolderType;
    /**
     * 
     * @type {UuidNullUUID}
     * @memberof BankBankAccount
     */
    'account_id'?: UuidNullUUID;
    /**
     * 
     * @type {BankAccountType}
     * @memberof BankBankAccount
     */
    'account_type'?: BankAccountType;
    /**
     * 
     * @type {Array<string>}
     * @memberof BankBankAccount
     */
    'available_payout_methods'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof BankBankAccount
     */
    'bank_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankBankAccount
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankBankAccount
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankBankAccount
     */
    'currency'?: string;
    /**
     * 
     * @type {CustomerCustomer}
     * @memberof BankBankAccount
     */
    'customer'?: CustomerCustomer;
    /**
     * 
     * @type {UuidNullUUID}
     * @memberof BankBankAccount
     */
    'customer_id'?: UuidNullUUID;
    /**
     * 
     * @type {boolean}
     * @memberof BankBankAccount
     */
    'default_for_currency'?: boolean;
    /**
     * 
     * @type {DatabaseDeletedAt}
     * @memberof BankBankAccount
     */
    'deleted_at'?: DatabaseDeletedAt;
    /**
     * 
     * @type {string}
     * @memberof BankBankAccount
     */
    'fingerprint'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankBankAccount
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankBankAccount
     */
    'last4'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BankBankAccount
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof BankBankAccount
     */
    'metadata'?: object;
    /**
     * 
     * @type {string}
     * @memberof BankBankAccount
     */
    'object'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankBankAccount
     */
    'routing_number'?: string;
    /**
     * 
     * @type {BankStatus}
     * @memberof BankBankAccount
     */
    'status'?: BankStatus;
    /**
     * 
     * @type {string}
     * @memberof BankBankAccount
     */
    'updated_at'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const BankStatus = {
    StatusNew: 'new',
    StatusValidated: 'validated',
    StatusVerified: 'verified',
    StatusVerificationFailed: 'verification_failed',
    StatusErrored: 'errored'
} as const;

export type BankStatus = typeof BankStatus[keyof typeof BankStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const CardAddressLine1Check = {
    AddressLine1CheckPass: 'pass',
    AddressLine1CheckFail: 'fail',
    AddressLine1CheckUnavailable: 'unavailable',
    AddressLine1CheckUnchecked: 'unchecked'
} as const;

export type CardAddressLine1Check = typeof CardAddressLine1Check[keyof typeof CardAddressLine1Check];


/**
 * 
 * @export
 * @enum {string}
 */

export const CardAddressZipCheck = {
    AddressZipCheckPass: 'pass',
    AddressZipCheckFail: 'fail',
    AddressZipCheckUnavailable: 'unavailable',
    AddressZipCheckUnchecked: 'unchecked'
} as const;

export type CardAddressZipCheck = typeof CardAddressZipCheck[keyof typeof CardAddressZipCheck];


/**
 * 
 * @export
 * @enum {string}
 */

export const CardBrand = {
    BrandAmericanExpress: 'American Express',
    BrandDinersClub: 'Diners Club',
    BrandDiscover: 'Discover',
    BrandJCB: 'JCB',
    BrandMasterCard: 'MasterCard',
    BrandUnionPay: 'UnionPay',
    BrandVisa: 'Visa',
    BrandUnknown: 'Unknown'
} as const;

export type CardBrand = typeof CardBrand[keyof typeof CardBrand];


/**
 * 
 * @export
 * @enum {string}
 */

export const CardCvcCheck = {
    CvcCheckPass: 'pass',
    CvcCheckFail: 'fail',
    CvcCheckUnavailable: 'unavailable',
    CvcCheckUnchecked: 'unchecked'
} as const;

export type CardCvcCheck = typeof CardCvcCheck[keyof typeof CardCvcCheck];


/**
 * 
 * @export
 * @enum {string}
 */

export const CardFunding = {
    FundingCredit: 'credit',
    FundingDebit: 'debit',
    FundingPrepaid: 'prepaid',
    FundingUnknown: 'unknown'
} as const;

export type CardFunding = typeof CardFunding[keyof typeof CardFunding];


/**
 * 
 * @export
 * @enum {string}
 */

export const CardTokenizationMethod = {
    TokenizationMethodAndroidPay: 'android_pay',
    TokenizationMethodApplePay: 'apple_pay',
    TokenizationMethodMasterpass: 'masterpass',
    TokenizationMethodVisaCheckout: 'visa_checkout',
    TokenizationMethodUnknown: 'unknown'
} as const;

export type CardTokenizationMethod = typeof CardTokenizationMethod[keyof typeof CardTokenizationMethod];


/**
 * 
 * @export
 * @interface CashCashBalance
 */
export interface CashCashBalance {
    /**
     * A hash of all cash balances available to this customer. You cannot delete a customer with any cash balances, even if the balance is 0. Amounts are represented in the [smallest currency unit](https://stripe.com/docs/currencies#zero-decimal).
     * @type {object}
     * @memberof CashCashBalance
     */
    'available'?: object;
    /**
     * 
     * @type {string}
     * @memberof CashCashBalance
     */
    'created_at'?: string;
    /**
     * The ID of the customer whose cash balance this object represents.
     * @type {string}
     * @memberof CashCashBalance
     */
    'customer'?: string;
    /**
     * 
     * @type {DatabaseDeletedAt}
     * @memberof CashCashBalance
     */
    'deleted_at'?: DatabaseDeletedAt;
    /**
     * 
     * @type {string}
     * @memberof CashCashBalance
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CashCashBalance
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof CashCashBalance
     */
    'metadata'?: object;
    /**
     * 
     * @type {string}
     * @memberof CashCashBalance
     */
    'object'?: string;
    /**
     * The configuration for how funds that land in the customer cash balance are reconciled.
     * @type {string}
     * @memberof CashCashBalance
     */
    'setting_reconciliation_mode'?: string;
    /**
     * A flag to indicate if reconciliation mode returned is the user\'s default or is specific to this customer cash balance
     * @type {boolean}
     * @memberof CashCashBalance
     */
    'setting_using_merchant_default'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CashCashBalance
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface ChargeCharge
 */
export interface ChargeCharge {
    /**
     * 
     * @type {number}
     * @memberof ChargeCharge
     */
    'amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ChargeCharge
     */
    'amount_captured'?: number;
    /**
     * 
     * @type {number}
     * @memberof ChargeCharge
     */
    'amount_refunded'?: number;
    /**
     * 
     * @type {string}
     * @memberof ChargeCharge
     */
    'balance_transaction'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChargeCharge
     */
    'billing_details'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChargeCharge
     */
    'calculated_statement_descriptor'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ChargeCharge
     */
    'captured'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ChargeCharge
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChargeCharge
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChargeCharge
     */
    'customer'?: string;
    /**
     * 
     * @type {DatabaseDeletedAt}
     * @memberof ChargeCharge
     */
    'deleted_at'?: DatabaseDeletedAt;
    /**
     * 
     * @type {string}
     * @memberof ChargeCharge
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ChargeCharge
     */
    'disputed'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ChargeCharge
     */
    'failure_balance_transaction'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChargeCharge
     */
    'failure_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChargeCharge
     */
    'failure_message'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChargeCharge
     */
    'fraud_details'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChargeCharge
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ChargeCharge
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof ChargeCharge
     */
    'metadata'?: object;
    /**
     * 
     * @type {string}
     * @memberof ChargeCharge
     */
    'object'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChargeCharge
     */
    'outcome'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ChargeCharge
     */
    'paid'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ChargeCharge
     */
    'payment_method'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChargeCharge
     */
    'payment_method_details'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChargeCharge
     */
    'radar_options'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChargeCharge
     */
    'receipt_email'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChargeCharge
     */
    'receipt_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChargeCharge
     */
    'receipt_url'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ChargeCharge
     */
    'refunded'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ChargeCharge
     */
    'review'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChargeCharge
     */
    'shipping'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChargeCharge
     */
    'statement_descriptor'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChargeCharge
     */
    'statement_descriptor_suffix'?: string;
    /**
     * 
     * @type {ChargeStatus}
     * @memberof ChargeCharge
     */
    'status'?: ChargeStatus;
    /**
     * 
     * @type {string}
     * @memberof ChargeCharge
     */
    'updated_at'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ChargeStatus = {
    StatusSucceeded: 'succeeded',
    StatusPending: 'pending',
    StatusFailed: 'failed'
} as const;

export type ChargeStatus = typeof ChargeStatus[keyof typeof ChargeStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const CheckoutBillingAddressCollection = {
    BillingAddressCollectionAuto: 'auto',
    BillingAddressCollectionRequired: 'required'
} as const;

export type CheckoutBillingAddressCollection = typeof CheckoutBillingAddressCollection[keyof typeof CheckoutBillingAddressCollection];


/**
 * 
 * @export
 * @interface CheckoutCheckoutSession
 */
export interface CheckoutCheckoutSession {
    /**
     * 
     * @type {string}
     * @memberof CheckoutCheckoutSession
     */
    'after_expiration'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CheckoutCheckoutSession
     */
    'allow_promotion_codes'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CheckoutCheckoutSession
     */
    'amount_subtotal'?: number;
    /**
     * 
     * @type {number}
     * @memberof CheckoutCheckoutSession
     */
    'amount_total'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CheckoutCheckoutSession
     */
    'automatic_tax'?: boolean;
    /**
     * 
     * @type {CheckoutBillingAddressCollection}
     * @memberof CheckoutCheckoutSession
     */
    'billing_address_collection'?: CheckoutBillingAddressCollection;
    /**
     * 
     * @type {string}
     * @memberof CheckoutCheckoutSession
     */
    'cancel_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutCheckoutSession
     */
    'client_reference_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutCheckoutSession
     */
    'consent'?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutCheckoutSession
     */
    'consent_collection'?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutCheckoutSession
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutCheckoutSession
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutCheckoutSession
     */
    'custom_text'?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutCheckoutSession
     */
    'customer'?: string;
    /**
     * 
     * @type {CheckoutCustomerCreation}
     * @memberof CheckoutCheckoutSession
     */
    'customer_creation'?: CheckoutCustomerCreation;
    /**
     * 
     * @type {string}
     * @memberof CheckoutCheckoutSession
     */
    'customer_details'?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutCheckoutSession
     */
    'customer_email'?: string;
    /**
     * 
     * @type {DatabaseDeletedAt}
     * @memberof CheckoutCheckoutSession
     */
    'deleted_at'?: DatabaseDeletedAt;
    /**
     * 
     * @type {number}
     * @memberof CheckoutCheckoutSession
     */
    'expires_at'?: number;
    /**
     * 
     * @type {string}
     * @memberof CheckoutCheckoutSession
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutCheckoutSession
     */
    'invoice'?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutCheckoutSession
     */
    'invoice_creation'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CheckoutCheckoutSession
     */
    'line_items'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof CheckoutCheckoutSession
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {CheckoutLocale}
     * @memberof CheckoutCheckoutSession
     */
    'locale'?: CheckoutLocale;
    /**
     * 
     * @type {object}
     * @memberof CheckoutCheckoutSession
     */
    'metadata'?: object;
    /**
     * 
     * @type {CheckoutMode}
     * @memberof CheckoutCheckoutSession
     */
    'mode'?: CheckoutMode;
    /**
     * 
     * @type {string}
     * @memberof CheckoutCheckoutSession
     */
    'object'?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutCheckoutSession
     */
    'payment_intent'?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutCheckoutSession
     */
    'payment_link'?: string;
    /**
     * 
     * @type {CheckoutPaymentMethodCollection}
     * @memberof CheckoutCheckoutSession
     */
    'payment_method_collection'?: CheckoutPaymentMethodCollection;
    /**
     * 
     * @type {string}
     * @memberof CheckoutCheckoutSession
     */
    'payment_method_options'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CheckoutCheckoutSession
     */
    'payment_method_types'?: Array<string>;
    /**
     * 
     * @type {CheckoutPaymentStatus}
     * @memberof CheckoutCheckoutSession
     */
    'payment_status'?: CheckoutPaymentStatus;
    /**
     * 
     * @type {boolean}
     * @memberof CheckoutCheckoutSession
     */
    'phone_number_collection'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CheckoutCheckoutSession
     */
    'recovered_from'?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutCheckoutSession
     */
    'setup_intent'?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutCheckoutSession
     */
    'shipping_address_collection'?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutCheckoutSession
     */
    'shipping_cost'?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutCheckoutSession
     */
    'shipping_details'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CheckoutCheckoutSession
     */
    'shipping_options'?: Array<string>;
    /**
     * 
     * @type {CheckoutStatus}
     * @memberof CheckoutCheckoutSession
     */
    'status'?: CheckoutStatus;
    /**
     * 
     * @type {CheckoutSubmitType}
     * @memberof CheckoutCheckoutSession
     */
    'submit_type'?: CheckoutSubmitType;
    /**
     * 
     * @type {string}
     * @memberof CheckoutCheckoutSession
     */
    'subscription'?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutCheckoutSession
     */
    'success_url'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CheckoutCheckoutSession
     */
    'tax_id_collection'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CheckoutCheckoutSession
     */
    'total_details'?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutCheckoutSession
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutCheckoutSession
     */
    'url'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const CheckoutCustomerCreation = {
    CustomerCreationIfRequired: 'if_required',
    CustomerCreationAlways: 'always'
} as const;

export type CheckoutCustomerCreation = typeof CheckoutCustomerCreation[keyof typeof CheckoutCustomerCreation];


/**
 * 
 * @export
 * @enum {string}
 */

export const CheckoutLocale = {
    Localeauto: 'auto',
    Localebg: 'bg',
    Localecs: 'cs',
    Localeda: 'da',
    Localede: 'de',
    Localeel: 'el',
    Localeen: 'en',
    Localeen_GB: 'en-GB',
    Localees: 'es',
    Localees_419: 'es-419',
    Localeet: 'et',
    Localefi: 'fi',
    Localefil: 'fil',
    Localefr: 'fr',
    Localefr_CA: 'fr-CA',
    Localehr: 'hr',
    Localehu: 'hu',
    Localeid: 'id',
    Localeit: 'it',
    Localeja: 'ja',
    Localeko: 'ko',
    Localelt: 'lt',
    Localelv: 'lv',
    Localems: 'ms',
    Localemt: 'mt',
    Localenb: 'nb',
    Localenl: 'nl',
    Localepl: 'pl',
    Localept: 'pt',
    Localept_BR: 'pt-BR',
    Localero: 'ro',
    Localeru: 'ru',
    Localesk: 'sk',
    Localesl: 'sl',
    Localesv: 'sv',
    Localeth: 'th',
    Localetr: 'tr',
    Localevi: 'vi',
    Localezh: 'zh',
    Localezh_HK: 'zh-HK',
    Localezh_TW: 'zh-TW'
} as const;

export type CheckoutLocale = typeof CheckoutLocale[keyof typeof CheckoutLocale];


/**
 * 
 * @export
 * @enum {string}
 */

export const CheckoutMode = {
    ModePayment: 'payment',
    ModeSetup: 'setup',
    ModeSubscription: 'subscription'
} as const;

export type CheckoutMode = typeof CheckoutMode[keyof typeof CheckoutMode];


/**
 * 
 * @export
 * @enum {string}
 */

export const CheckoutPaymentMethodCollection = {
    PaymentMethodCollectionAlways: 'always',
    PaymentMethodCollectionIfRequired: 'if_required'
} as const;

export type CheckoutPaymentMethodCollection = typeof CheckoutPaymentMethodCollection[keyof typeof CheckoutPaymentMethodCollection];


/**
 * 
 * @export
 * @enum {string}
 */

export const CheckoutPaymentStatus = {
    PaymentStatusPaid: 'paid',
    PaymentStatusUnpaid: 'unpaid',
    PaymentStatusNoPaymentRequired: 'no_payment_required'
} as const;

export type CheckoutPaymentStatus = typeof CheckoutPaymentStatus[keyof typeof CheckoutPaymentStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const CheckoutStatus = {
    StatusOpen: 'open',
    StatusComplete: 'complete',
    StatusExpired: 'expired'
} as const;

export type CheckoutStatus = typeof CheckoutStatus[keyof typeof CheckoutStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const CheckoutSubmitType = {
    SubmitTypeAuto: 'auto',
    SubmitTypePay: 'pay',
    SubmitTypeBook: 'book',
    SubmitTypeDonate: 'donate'
} as const;

export type CheckoutSubmitType = typeof CheckoutSubmitType[keyof typeof CheckoutSubmitType];


/**
 * 
 * @export
 * @interface CouponCoupon
 */
export interface CouponCoupon {
    /**
     * 
     * @type {number}
     * @memberof CouponCoupon
     */
    'amount_off'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof CouponCoupon
     */
    'applies_to'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CouponCoupon
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof CouponCoupon
     */
    'currency'?: string;
    /**
     * 
     * @type {DatabaseDeletedAt}
     * @memberof CouponCoupon
     */
    'deleted_at'?: DatabaseDeletedAt;
    /**
     * 
     * @type {CouponDuration}
     * @memberof CouponCoupon
     */
    'duration'?: CouponDuration;
    /**
     * 
     * @type {number}
     * @memberof CouponCoupon
     */
    'duration_in_months'?: number;
    /**
     * 
     * @type {string}
     * @memberof CouponCoupon
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CouponCoupon
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CouponCoupon
     */
    'max_redemptions'?: number;
    /**
     * 
     * @type {object}
     * @memberof CouponCoupon
     */
    'metadata'?: object;
    /**
     * 
     * @type {string}
     * @memberof CouponCoupon
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CouponCoupon
     */
    'object'?: string;
    /**
     * 
     * @type {number}
     * @memberof CouponCoupon
     */
    'percent_off'?: number;
    /**
     * 
     * @type {number}
     * @memberof CouponCoupon
     */
    'redeem_by'?: number;
    /**
     * 
     * @type {number}
     * @memberof CouponCoupon
     */
    'times_redeemed'?: number;
    /**
     * 
     * @type {string}
     * @memberof CouponCoupon
     */
    'updated_at'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CouponCoupon
     */
    'valid'?: boolean;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const CouponDuration = {
    DurationOnce: 'once',
    DurationRepeating: 'repeating',
    DurationForever: 'forever'
} as const;

export type CouponDuration = typeof CouponDuration[keyof typeof CouponDuration];


/**
 * 
 * @export
 * @interface CreditCreditNote
 */
export interface CreditCreditNote {
    /**
     * The integer amount in %s representing the total amount of the credit note, including tax.
     * @type {number}
     * @memberof CreditCreditNote
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreditCreditNote
     */
    'created_at'?: string;
    /**
     * Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
     * @type {string}
     * @memberof CreditCreditNote
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreditCreditNote
     */
    'customer'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreditCreditNote
     */
    'customer_balance_transaction'?: string;
    /**
     * 
     * @type {DatabaseDeletedAt}
     * @memberof CreditCreditNote
     */
    'deleted_at'?: DatabaseDeletedAt;
    /**
     * The integer amount in %s representing the total amount of discount that was credited.
     * @type {number}
     * @memberof CreditCreditNote
     */
    'discount_amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreditCreditNote
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreditCreditNote
     */
    'invoice'?: string;
    /**
     * The aggregate amounts calculated per discount for all line items.
     * @type {Array<string>}
     * @memberof CreditCreditNote
     */
    'lines'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof CreditCreditNote
     */
    'livemode'?: boolean;
    /**
     * Customer-facing text that appears on the credit note PDF.
     * @type {string}
     * @memberof CreditCreditNote
     */
    'memo'?: string;
    /**
     * 
     * @type {object}
     * @memberof CreditCreditNote
     */
    'metadata'?: object;
    /**
     * A unique number that identifies this particular credit note and appears on the PDF of the credit note and its associated invoice.
     * @type {string}
     * @memberof CreditCreditNote
     */
    'number'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreditCreditNote
     */
    'object'?: string;
    /**
     * Amount that was credited outside of Stripe.
     * @type {number}
     * @memberof CreditCreditNote
     */
    'out_of_band_amount'?: number;
    /**
     * The link to download the PDF of the credit note.
     * @type {string}
     * @memberof CreditCreditNote
     */
    'pdf'?: string;
    /**
     * Reason for issuing this credit note, one of `duplicate`, `fraudulent`, `order_change`, or `product_unsatisfactory`
     * @type {string}
     * @memberof CreditCreditNote
     */
    'reason'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreditCreditNote
     */
    'refund'?: string;
    /**
     * Status of this credit note, one of `issued` or `void`. Learn more about [voiding credit notes](https://stripe.com/docs/billing/invoices/credit-notes#voiding).
     * @type {string}
     * @memberof CreditCreditNote
     */
    'status'?: string;
    /**
     * The integer amount in %s representing the amount of the credit note, excluding exclusive tax and invoice level discounts.
     * @type {number}
     * @memberof CreditCreditNote
     */
    'subtotal'?: number;
    /**
     * The integer amount in %s representing the amount of the credit note, excluding all tax and invoice level discounts.
     * @type {number}
     * @memberof CreditCreditNote
     */
    'subtotal_excluding_tax'?: number;
    /**
     * The aggregate amounts calculated per tax rate for all line items.
     * @type {Array<string>}
     * @memberof CreditCreditNote
     */
    'tax_amounts'?: Array<string>;
    /**
     * The integer amount in %s representing the total amount of the credit note, including tax and all discount.
     * @type {number}
     * @memberof CreditCreditNote
     */
    'total'?: number;
    /**
     * The integer amount in %s representing the total amount of the credit note, excluding tax, but including discounts.
     * @type {number}
     * @memberof CreditCreditNote
     */
    'total_excluding_tax'?: number;
    /**
     * Type of this credit note, one of `pre_payment` or `post_payment`. A `pre_payment` credit note means it was issued when the invoice was open. A `post_payment` credit note means it was issued when the invoice was paid.
     * @type {CreditType}
     * @memberof CreditCreditNote
     */
    'type'?: CreditType;
    /**
     * 
     * @type {string}
     * @memberof CreditCreditNote
     */
    'updated_at'?: string;
    /**
     * The time that the credit note was voided.
     * @type {string}
     * @memberof CreditCreditNote
     */
    'voided_at'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CreditType = {
    TypePrePayment: 'pre_payment',
    TypePostPayment: 'post_payment'
} as const;

export type CreditType = typeof CreditType[keyof typeof CreditType];


/**
 * 
 * @export
 * @interface CustomerCustomer
 */
export interface CustomerCustomer {
    /**
     * 
     * @type {string}
     * @memberof CustomerCustomer
     */
    'address'?: string;
    /**
     * 
     * @type {number}
     * @memberof CustomerCustomer
     */
    'balance'?: number;
    /**
     * 
     * @type {string}
     * @memberof CustomerCustomer
     */
    'created_at'?: string;
    /**
     * CashBalance          *CashBalance                     `json:\"cash_balance,omitempty\"`
     * @type {string}
     * @memberof CustomerCustomer
     */
    'currency'?: string;
    /**
     * 
     * @type {DatabaseDeletedAt}
     * @memberof CustomerCustomer
     */
    'deleted_at'?: DatabaseDeletedAt;
    /**
     * 
     * @type {boolean}
     * @memberof CustomerCustomer
     */
    'delinquent'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CustomerCustomer
     */
    'description'?: string;
    /**
     * Discount             *Discount                        `json:\"discount,omitempty\"`
     * @type {string}
     * @memberof CustomerCustomer
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerCustomer
     */
    'id'?: string;
    /**
     * 
     * @type {object}
     * @memberof CustomerCustomer
     */
    'invoice_credit_balance'?: object;
    /**
     * 
     * @type {string}
     * @memberof CustomerCustomer
     */
    'invoice_prefix'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerCustomer
     */
    'invoice_settings'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CustomerCustomer
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof CustomerCustomer
     */
    'metadata'?: object;
    /**
     * 
     * @type {string}
     * @memberof CustomerCustomer
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof CustomerCustomer
     */
    'next_invoice_sequence'?: number;
    /**
     * 
     * @type {string}
     * @memberof CustomerCustomer
     */
    'object'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerCustomer
     */
    'phone'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CustomerCustomer
     */
    'preferred_locales'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CustomerCustomer
     */
    'shipping'?: string;
    /**
     * Sources              *ApmsSourcesSourceList                  `json:\"sources,omitempty\"` Subscriptions        *SubscriptionList                       `json:\"subscriptions,omitempty\"`
     * @type {string}
     * @memberof CustomerCustomer
     */
    'tax'?: string;
    /**
     * 
     * @type {CustomerTaxExempt}
     * @memberof CustomerCustomer
     */
    'tax_exempt'?: CustomerTaxExempt;
    /**
     * 
     * @type {string}
     * @memberof CustomerCustomer
     */
    'updated_at'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const CustomerTaxExempt = {
    TaxExemptNone: 'none',
    TaxExemptExempt: 'exempt',
    TaxExemptReverse: 'reverse'
} as const;

export type CustomerTaxExempt = typeof CustomerTaxExempt[keyof typeof CustomerTaxExempt];


/**
 * 
 * @export
 * @interface DatabaseDeletedAt
 */
export interface DatabaseDeletedAt {
    /**
     * 
     * @type {string}
     * @memberof DatabaseDeletedAt
     */
    'time'?: string;
    /**
     * Valid is true if Time is not NULL
     * @type {boolean}
     * @memberof DatabaseDeletedAt
     */
    'valid'?: boolean;
}
/**
 * 
 * @export
 * @interface DiscountDiscount
 */
export interface DiscountDiscount {
    /**
     * 
     * @type {number}
     * @memberof DiscountDiscount
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof DiscountDiscount
     */
    'checkout_session'?: string;
    /**
     * 
     * @type {string}
     * @memberof DiscountDiscount
     */
    'coupon'?: string;
    /**
     * 
     * @type {string}
     * @memberof DiscountDiscount
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DiscountDiscount
     */
    'customer'?: string;
    /**
     * 
     * @type {DatabaseDeletedAt}
     * @memberof DiscountDiscount
     */
    'deleted_at'?: DatabaseDeletedAt;
    /**
     * 
     * @type {number}
     * @memberof DiscountDiscount
     */
    'end'?: number;
    /**
     * 
     * @type {string}
     * @memberof DiscountDiscount
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DiscountDiscount
     */
    'invoice'?: string;
    /**
     * 
     * @type {string}
     * @memberof DiscountDiscount
     */
    'invoice_item'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DiscountDiscount
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof DiscountDiscount
     */
    'metadata'?: object;
    /**
     * 
     * @type {string}
     * @memberof DiscountDiscount
     */
    'object'?: string;
    /**
     * 
     * @type {string}
     * @memberof DiscountDiscount
     */
    'promotion_code'?: string;
    /**
     * 
     * @type {number}
     * @memberof DiscountDiscount
     */
    'start'?: number;
    /**
     * 
     * @type {string}
     * @memberof DiscountDiscount
     */
    'subscription'?: string;
    /**
     * 
     * @type {string}
     * @memberof DiscountDiscount
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface DisputeDispute
 */
export interface DisputeDispute {
    /**
     * Disputed amount. Usually the amount of the charge, but can differ (usually because of currency fluctuation or because only part of the order is disputed).
     * @type {number}
     * @memberof DisputeDispute
     */
    'amount'?: number;
    /**
     * List of zero, one, or two balance transactions that show funds withdrawn and reinstated to your Stripe account as a result of this dispute.
     * @type {Array<string>}
     * @memberof DisputeDispute
     */
    'balance_transactions'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DisputeDispute
     */
    'charge'?: string;
    /**
     * 
     * @type {string}
     * @memberof DisputeDispute
     */
    'created_at'?: string;
    /**
     * Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
     * @type {string}
     * @memberof DisputeDispute
     */
    'currency'?: string;
    /**
     * 
     * @type {DatabaseDeletedAt}
     * @memberof DisputeDispute
     */
    'deleted_at'?: DatabaseDeletedAt;
    /**
     * 
     * @type {string}
     * @memberof DisputeDispute
     */
    'evidence'?: string;
    /**
     * 
     * @type {string}
     * @memberof DisputeDispute
     */
    'evidence_details'?: string;
    /**
     * 
     * @type {string}
     * @memberof DisputeDispute
     */
    'id'?: string;
    /**
     * If true, it is still possible to refund the disputed payment. Once the payment has been fully refunded, no further funds will be withdrawn from your Stripe account as a result of this dispute.
     * @type {boolean}
     * @memberof DisputeDispute
     */
    'is_charge_refundable'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DisputeDispute
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof DisputeDispute
     */
    'metadata'?: object;
    /**
     * 
     * @type {string}
     * @memberof DisputeDispute
     */
    'object'?: string;
    /**
     * 
     * @type {string}
     * @memberof DisputeDispute
     */
    'payment_intent'?: string;
    /**
     * Reason given by cardholder for dispute. Possible values are `bank_cannot_process`, `check_returned`, `credit_not_processed`, `customer_initiated`, `debit_not_authorized`, `duplicate`, `fraudulent`, `general`, `incorrect_account_details`, `insufficient_funds`, `product_not_received`, `product_unacceptable`, `subscription_canceled`, or `unrecognized`. Read more about [dispute reasons](https://stripe.com/docs/disputes/categories).
     * @type {DisputeReason}
     * @memberof DisputeDispute
     */
    'reason'?: DisputeReason;
    /**
     * Current status of dispute. Possible values are `warning_needs_response`, `warning_under_review`, `warning_closed`, `needs_response`, `under_review`, `charge_refunded`, `won`, or `lost`.
     * @type {DisputeStatus}
     * @memberof DisputeDispute
     */
    'status'?: DisputeStatus;
    /**
     * 
     * @type {string}
     * @memberof DisputeDispute
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const DisputeReason = {
    ReasonBankCannotProcess: 'bank_cannot_process',
    ReasonCheckReturned: 'check_returned',
    ReasonCreditNotProcessed: 'credit_not_processed',
    ReasonCustomerInitiated: 'customer_initiated',
    ReasonDebitNotAuthorized: 'debit_not_authorized',
    ReasonDuplicate: 'duplicate',
    ReasonFraudulent: 'fraudulent',
    ReasonGeneral: 'general',
    ReasonIncorrectAccountDetails: 'incorrect_account_details',
    ReasonInsufficientFunds: 'insufficient_funds',
    ReasonProductNotReceived: 'product_not_received',
    ReasonProductUnacceptable: 'product_unacceptable',
    ReasonSubscriptionCanceled: 'subscription_canceled',
    ReasonUnrecognized: 'unrecognized'
} as const;

export type DisputeReason = typeof DisputeReason[keyof typeof DisputeReason];


/**
 * 
 * @export
 * @enum {string}
 */

export const DisputeStatus = {
    StatusWarningNeedsResponse: 'warning_needs_response',
    StatusWarningUnderReview: 'warning_under_review',
    StatusWarningClosed: 'warning_closed',
    StatusNeedsResponse: 'needs_response',
    StatusUnderReview: 'under_review',
    StatusChargeRefunded: 'charge_refunded',
    StatusWon: 'won',
    StatusLost: 'lost'
} as const;

export type DisputeStatus = typeof DisputeStatus[keyof typeof DisputeStatus];


/**
 * 
 * @export
 * @interface FileFile
 */
export interface FileFile {
    /**
     * 
     * @type {string}
     * @memberof FileFile
     */
    'created_at'?: string;
    /**
     * 
     * @type {DatabaseDeletedAt}
     * @memberof FileFile
     */
    'deleted_at'?: DatabaseDeletedAt;
    /**
     * The time at which the file expires and is no longer available in epoch seconds.
     * @type {number}
     * @memberof FileFile
     */
    'expires_at'?: number;
    /**
     * A filename for the file, suitable for saving to a filesystem.
     * @type {string}
     * @memberof FileFile
     */
    'filename'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileFile
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileFile
     */
    'links'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FileFile
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof FileFile
     */
    'metadata'?: object;
    /**
     * 
     * @type {string}
     * @memberof FileFile
     */
    'object'?: string;
    /**
     * The [purpose](https://stripe.com/docs/file-upload#uploading-a-file) of the uploaded file.
     * @type {FilePurpose}
     * @memberof FileFile
     */
    'purpose'?: FilePurpose;
    /**
     * The size in bytes of the file object.
     * @type {number}
     * @memberof FileFile
     */
    'size'?: number;
    /**
     * A user friendly title for the document.
     * @type {string}
     * @memberof FileFile
     */
    'title'?: string;
    /**
     * The type of the file returned (e.g., `csv`, `pdf`, `jpg`, or `png`).
     * @type {string}
     * @memberof FileFile
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileFile
     */
    'updated_at'?: string;
    /**
     * The URL from which the file can be downloaded using your live secret API key.
     * @type {string}
     * @memberof FileFile
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const FilePurpose = {
    PurposeAccountRequirement: 'account_requirement',
    PurposeAdditionalVerification: 'additional_verification',
    PurposeBusinessIcon: 'business_icon',
    PurposeBusinesslogo: 'business_logo',
    PurposeCustomerSignature: 'customer_signature',
    PurposeDisputeEvidence: 'dispute_evidence',
    PurposeDocumentProviderIdentityDocument: 'document_provider_identity_document',
    PurposeFinanceReportRun: 'finance_report_run',
    PurposeIdentityDocument: 'identity_document',
    PurposeIdentityDocumentDownloadable: 'identity_document_downloadable',
    PurposePciDocument: 'pci_document',
    PurposeSelfie: 'selfie',
    PurposeSigmaScheduledQuery: 'sigma_scheduled_query',
    PurposeTaxDocumentUserUpload: 'tax_document_user_upload',
    PurposeTerminalReaderSplashscreen: 'terminal_reader_splashscreen'
} as const;

export type FilePurpose = typeof FilePurpose[keyof typeof FilePurpose];


/**
 * 
 * @export
 * @enum {string}
 */

export const GithubComDriver005GatewayInternalIntentCancellationReason = {
    CancellationReasonDuplicate: 'duplicate',
    CancellationReasonFraudulent: 'fraudulent',
    CancellationReasonRequestedByCustomer: 'requested_by_customer',
    CancellationReasonAbandoned: 'abandoned',
    CancellationReasonFailedInvoice: 'failed_invoice',
    CancellationReasonVoidInvoice: 'void_invoice',
    CancellationReasonAutomatic: 'automatic'
} as const;

export type GithubComDriver005GatewayInternalIntentCancellationReason = typeof GithubComDriver005GatewayInternalIntentCancellationReason[keyof typeof GithubComDriver005GatewayInternalIntentCancellationReason];


/**
 * 
 * @export
 * @enum {string}
 */

export const GithubComDriver005GatewayInternalIntentStatus = {
    StatusRequiresPaymentMethod: 'requires_payment_method',
    StatusRequiresConfirmation: 'requires_confirmation',
    StatusRequiresAction: 'requires_action',
    StatusProcessing: 'processing',
    StatusRequiresCapture: 'requires_capture',
    StatusCanceled: 'canceled',
    StatusSucceeded: 'succeeded'
} as const;

export type GithubComDriver005GatewayInternalIntentStatus = typeof GithubComDriver005GatewayInternalIntentStatus[keyof typeof GithubComDriver005GatewayInternalIntentStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const GithubComDriver005GatewayInternalSetupIntentCancellationReason = {
    CancellationReasonAbandoned: 'abandoned',
    CancellationReasonRequestedByCustomer: 'requested_by_customer',
    CancellationReasonDuplicate: 'duplicate'
} as const;

export type GithubComDriver005GatewayInternalSetupIntentCancellationReason = typeof GithubComDriver005GatewayInternalSetupIntentCancellationReason[keyof typeof GithubComDriver005GatewayInternalSetupIntentCancellationReason];


/**
 * 
 * @export
 * @enum {string}
 */

export const GithubComDriver005GatewayInternalSetupIntentStatus = {
    StatusRequiresPaymentMethod: 'requires_payment_method',
    StatusRequiresConfirmation: 'requires_confirmation',
    StatusRequiresAction: 'requires_action',
    StatusProcessing: 'processing',
    StatusSucceeded: 'succeeded',
    StatusFailed: 'failed',
    StatusAbandoned: 'abandoned'
} as const;

export type GithubComDriver005GatewayInternalSetupIntentStatus = typeof GithubComDriver005GatewayInternalSetupIntentStatus[keyof typeof GithubComDriver005GatewayInternalSetupIntentStatus];


/**
 * 
 * @export
 * @interface GithubComDriver005GatewayPaymentCardCard
 */
export interface GithubComDriver005GatewayPaymentCardCard {
    /**
     * 
     * @type {string}
     * @memberof GithubComDriver005GatewayPaymentCardCard
     */
    'account'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComDriver005GatewayPaymentCardCard
     */
    'address_city'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComDriver005GatewayPaymentCardCard
     */
    'address_country'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComDriver005GatewayPaymentCardCard
     */
    'address_line1'?: string;
    /**
     * 
     * @type {CardAddressLine1Check}
     * @memberof GithubComDriver005GatewayPaymentCardCard
     */
    'address_line1_check'?: CardAddressLine1Check;
    /**
     * 
     * @type {string}
     * @memberof GithubComDriver005GatewayPaymentCardCard
     */
    'address_line2'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComDriver005GatewayPaymentCardCard
     */
    'address_state'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComDriver005GatewayPaymentCardCard
     */
    'address_zip'?: string;
    /**
     * 
     * @type {CardAddressZipCheck}
     * @memberof GithubComDriver005GatewayPaymentCardCard
     */
    'address_zip_check'?: CardAddressZipCheck;
    /**
     * 
     * @type {Array<string>}
     * @memberof GithubComDriver005GatewayPaymentCardCard
     */
    'available_payout_methods'?: Array<string>;
    /**
     * 
     * @type {CardBrand}
     * @memberof GithubComDriver005GatewayPaymentCardCard
     */
    'brand'?: CardBrand;
    /**
     * 
     * @type {string}
     * @memberof GithubComDriver005GatewayPaymentCardCard
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComDriver005GatewayPaymentCardCard
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComDriver005GatewayPaymentCardCard
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComDriver005GatewayPaymentCardCard
     */
    'customer'?: string;
    /**
     * 
     * @type {CardCvcCheck}
     * @memberof GithubComDriver005GatewayPaymentCardCard
     */
    'cvc_check'?: CardCvcCheck;
    /**
     * 
     * @type {boolean}
     * @memberof GithubComDriver005GatewayPaymentCardCard
     */
    'default_for_currency'?: boolean;
    /**
     * 
     * @type {DatabaseDeletedAt}
     * @memberof GithubComDriver005GatewayPaymentCardCard
     */
    'deleted_at'?: DatabaseDeletedAt;
    /**
     * 
     * @type {string}
     * @memberof GithubComDriver005GatewayPaymentCardCard
     */
    'dynamic_last4'?: string;
    /**
     * 
     * @type {number}
     * @memberof GithubComDriver005GatewayPaymentCardCard
     */
    'exp_month'?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComDriver005GatewayPaymentCardCard
     */
    'exp_year'?: number;
    /**
     * 
     * @type {string}
     * @memberof GithubComDriver005GatewayPaymentCardCard
     */
    'fingerprint'?: string;
    /**
     * 
     * @type {CardFunding}
     * @memberof GithubComDriver005GatewayPaymentCardCard
     */
    'funding'?: CardFunding;
    /**
     * 
     * @type {string}
     * @memberof GithubComDriver005GatewayPaymentCardCard
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComDriver005GatewayPaymentCardCard
     */
    'last4'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GithubComDriver005GatewayPaymentCardCard
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof GithubComDriver005GatewayPaymentCardCard
     */
    'metadata'?: object;
    /**
     * 
     * @type {string}
     * @memberof GithubComDriver005GatewayPaymentCardCard
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComDriver005GatewayPaymentCardCard
     */
    'object'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComDriver005GatewayPaymentCardCard
     */
    'status'?: string;
    /**
     * 
     * @type {CardTokenizationMethod}
     * @memberof GithubComDriver005GatewayPaymentCardCard
     */
    'tokenization_method'?: CardTokenizationMethod;
    /**
     * 
     * @type {string}
     * @memberof GithubComDriver005GatewayPaymentCardCard
     */
    'updated_at'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const IntentCaptureMethod = {
    CaptureMethodAutomatic: 'automatic',
    CaptureMethodManual: 'manual'
} as const;

export type IntentCaptureMethod = typeof IntentCaptureMethod[keyof typeof IntentCaptureMethod];


/**
 * 
 * @export
 * @enum {string}
 */

export const IntentConfirmationMethod = {
    ConfirmationMethodAutomatic: 'automatic',
    ConfirmationMethodManual: 'manual'
} as const;

export type IntentConfirmationMethod = typeof IntentConfirmationMethod[keyof typeof IntentConfirmationMethod];


/**
 * 
 * @export
 * @interface IntentPaymentIntent
 */
export interface IntentPaymentIntent {
    /**
     * 
     * @type {number}
     * @memberof IntentPaymentIntent
     */
    'amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof IntentPaymentIntent
     */
    'amount_capturable'?: number;
    /**
     * 
     * @type {string}
     * @memberof IntentPaymentIntent
     */
    'amount_details'?: string;
    /**
     * 
     * @type {number}
     * @memberof IntentPaymentIntent
     */
    'amount_received'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof IntentPaymentIntent
     */
    'automatic_payment_methods'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof IntentPaymentIntent
     */
    'canceled_at'?: number;
    /**
     * 
     * @type {GithubComDriver005GatewayInternalIntentCancellationReason}
     * @memberof IntentPaymentIntent
     */
    'cancellation_reason'?: GithubComDriver005GatewayInternalIntentCancellationReason;
    /**
     * 
     * @type {IntentCaptureMethod}
     * @memberof IntentPaymentIntent
     */
    'capture_method'?: IntentCaptureMethod;
    /**
     * 
     * @type {string}
     * @memberof IntentPaymentIntent
     */
    'client_secret'?: string;
    /**
     * 
     * @type {IntentConfirmationMethod}
     * @memberof IntentPaymentIntent
     */
    'confirmation_method'?: IntentConfirmationMethod;
    /**
     * 
     * @type {string}
     * @memberof IntentPaymentIntent
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof IntentPaymentIntent
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof IntentPaymentIntent
     */
    'customer'?: string;
    /**
     * 
     * @type {DatabaseDeletedAt}
     * @memberof IntentPaymentIntent
     */
    'deleted_at'?: DatabaseDeletedAt;
    /**
     * 
     * @type {string}
     * @memberof IntentPaymentIntent
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof IntentPaymentIntent
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof IntentPaymentIntent
     */
    'last_payment_error'?: string;
    /**
     * 
     * @type {string}
     * @memberof IntentPaymentIntent
     */
    'latest_charge'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof IntentPaymentIntent
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof IntentPaymentIntent
     */
    'metadata'?: object;
    /**
     * 
     * @type {string}
     * @memberof IntentPaymentIntent
     */
    'next_action'?: string;
    /**
     * 
     * @type {string}
     * @memberof IntentPaymentIntent
     */
    'object'?: string;
    /**
     * 
     * @type {string}
     * @memberof IntentPaymentIntent
     */
    'payment_method'?: string;
    /**
     * 
     * @type {string}
     * @memberof IntentPaymentIntent
     */
    'payment_method_options'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof IntentPaymentIntent
     */
    'payment_method_types'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof IntentPaymentIntent
     */
    'processing'?: string;
    /**
     * 
     * @type {string}
     * @memberof IntentPaymentIntent
     */
    'receipt_email'?: string;
    /**
     * 
     * @type {string}
     * @memberof IntentPaymentIntent
     */
    'review'?: string;
    /**
     * 
     * @type {IntentSetupFutureUsage}
     * @memberof IntentPaymentIntent
     */
    'setup_future_usage'?: IntentSetupFutureUsage;
    /**
     * 
     * @type {string}
     * @memberof IntentPaymentIntent
     */
    'shipping'?: string;
    /**
     * 
     * @type {string}
     * @memberof IntentPaymentIntent
     */
    'statement_descriptor'?: string;
    /**
     * 
     * @type {string}
     * @memberof IntentPaymentIntent
     */
    'statement_descriptor_suffix'?: string;
    /**
     * 
     * @type {GithubComDriver005GatewayInternalIntentStatus}
     * @memberof IntentPaymentIntent
     */
    'status'?: GithubComDriver005GatewayInternalIntentStatus;
    /**
     * 
     * @type {string}
     * @memberof IntentPaymentIntent
     */
    'updated_at'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const IntentSetupFutureUsage = {
    SetupFutureUsageOffSession: 'off_session',
    SetupFutureUsageOnSession: 'on_session'
} as const;

export type IntentSetupFutureUsage = typeof IntentSetupFutureUsage[keyof typeof IntentSetupFutureUsage];


/**
 * 
 * @export
 * @interface IntentSetupIntent
 */
export interface IntentSetupIntent {
    /**
     * 
     * @type {boolean}
     * @memberof IntentSetupIntent
     */
    'attach_to_self'?: boolean;
    /**
     * 
     * @type {GithubComDriver005GatewayInternalSetupIntentCancellationReason}
     * @memberof IntentSetupIntent
     */
    'cancellation_reason'?: GithubComDriver005GatewayInternalSetupIntentCancellationReason;
    /**
     * 
     * @type {string}
     * @memberof IntentSetupIntent
     */
    'client_secret'?: string;
    /**
     * 
     * @type {string}
     * @memberof IntentSetupIntent
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof IntentSetupIntent
     */
    'customer'?: string;
    /**
     * 
     * @type {DatabaseDeletedAt}
     * @memberof IntentSetupIntent
     */
    'deleted_at'?: DatabaseDeletedAt;
    /**
     * 
     * @type {string}
     * @memberof IntentSetupIntent
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof IntentSetupIntent
     */
    'flow_directions'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof IntentSetupIntent
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof IntentSetupIntent
     */
    'last_setup_error'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof IntentSetupIntent
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IntentSetupIntent
     */
    'mandate'?: string;
    /**
     * 
     * @type {object}
     * @memberof IntentSetupIntent
     */
    'metadata'?: object;
    /**
     * 
     * @type {string}
     * @memberof IntentSetupIntent
     */
    'next_action'?: string;
    /**
     * 
     * @type {string}
     * @memberof IntentSetupIntent
     */
    'object'?: string;
    /**
     * 
     * @type {string}
     * @memberof IntentSetupIntent
     */
    'payment_method'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof IntentSetupIntent
     */
    'payment_method_types'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof IntentSetupIntent
     */
    'single_use_mandate'?: string;
    /**
     * 
     * @type {GithubComDriver005GatewayInternalSetupIntentStatus}
     * @memberof IntentSetupIntent
     */
    'status'?: GithubComDriver005GatewayInternalSetupIntentStatus;
    /**
     * 
     * @type {string}
     * @memberof IntentSetupIntent
     */
    'updated_at'?: string;
    /**
     * 
     * @type {IntentUsage}
     * @memberof IntentSetupIntent
     */
    'usage'?: IntentUsage;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const IntentUsage = {
    UsageOffSession: 'off_session',
    UsageOnSession: 'on_session'
} as const;

export type IntentUsage = typeof IntentUsage[keyof typeof IntentUsage];


/**
 * 
 * @export
 * @enum {string}
 */

export const InvoiceBillingReason = {
    BillingReasonSubscriptionCycle: 'subscription_cycle',
    BillingReasonSubscriptionCreate: 'subscription_create',
    BillingReasonSubscriptionUpdate: 'subscription_update',
    BillingReasonSubscriptionThreshold: 'subscription_threshold',
    BillingReasonSubscription: 'subscription',
    BillingReasonManual: 'manual',
    BillingReasonUpcoming: 'upcoming'
} as const;

export type InvoiceBillingReason = typeof InvoiceBillingReason[keyof typeof InvoiceBillingReason];


/**
 * 
 * @export
 * @enum {string}
 */

export const InvoiceCollectionMethod = {
    CollectionMethodChargeAutomatically: 'charge_automatically',
    CollectionMethodSendInvoiced: 'send_invoice'
} as const;

export type InvoiceCollectionMethod = typeof InvoiceCollectionMethod[keyof typeof InvoiceCollectionMethod];


/**
 * 
 * @export
 * @interface InvoiceInvoice
 */
export interface InvoiceInvoice {
    /**
     * 
     * @type {string}
     * @memberof InvoiceInvoice
     */
    'account_country'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceInvoice
     */
    'account_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceInvoice
     */
    'account_tax_ids'?: string;
    /**
     * 
     * @type {number}
     * @memberof InvoiceInvoice
     */
    'amount_due'?: number;
    /**
     * 
     * @type {number}
     * @memberof InvoiceInvoice
     */
    'amount_paid'?: number;
    /**
     * 
     * @type {number}
     * @memberof InvoiceInvoice
     */
    'amount_remaining'?: number;
    /**
     * 
     * @type {number}
     * @memberof InvoiceInvoice
     */
    'attempt_count'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof InvoiceInvoice
     */
    'attempted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InvoiceInvoice
     */
    'auto_advance'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InvoiceInvoice
     */
    'automatic_tax'?: string;
    /**
     * 
     * @type {InvoiceBillingReason}
     * @memberof InvoiceInvoice
     */
    'billing_reason'?: InvoiceBillingReason;
    /**
     * 
     * @type {string}
     * @memberof InvoiceInvoice
     */
    'charge'?: string;
    /**
     * 
     * @type {InvoiceCollectionMethod}
     * @memberof InvoiceInvoice
     */
    'collection_method'?: InvoiceCollectionMethod;
    /**
     * 
     * @type {string}
     * @memberof InvoiceInvoice
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceInvoice
     */
    'currency'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InvoiceInvoice
     */
    'custom_fields'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof InvoiceInvoice
     */
    'customer'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceInvoice
     */
    'customer_address'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceInvoice
     */
    'customer_email'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceInvoice
     */
    'customer_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceInvoice
     */
    'customer_phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceInvoice
     */
    'customer_shipping'?: string;
    /**
     * 
     * @type {CustomerTaxExempt}
     * @memberof InvoiceInvoice
     */
    'customer_tax_exempt'?: CustomerTaxExempt;
    /**
     * 
     * @type {Array<string>}
     * @memberof InvoiceInvoice
     */
    'customer_tax_ids'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof InvoiceInvoice
     */
    'default_payment_method'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceInvoice
     */
    'default_tax_rates'?: string;
    /**
     * 
     * @type {DatabaseDeletedAt}
     * @memberof InvoiceInvoice
     */
    'deleted_at'?: DatabaseDeletedAt;
    /**
     * 
     * @type {string}
     * @memberof InvoiceInvoice
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InvoiceInvoice
     */
    'discountable'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof InvoiceInvoice
     */
    'discounts'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof InvoiceInvoice
     */
    'due_date'?: string;
    /**
     * 
     * @type {number}
     * @memberof InvoiceInvoice
     */
    'ending_balance'?: number;
    /**
     * 
     * @type {string}
     * @memberof InvoiceInvoice
     */
    'footer'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceInvoice
     */
    'from_invoice'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceInvoice
     */
    'hosted_invoice_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceInvoice
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceInvoice
     */
    'invoice_pdf'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceInvoice
     */
    'last_finalization_error'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceInvoice
     */
    'latest_revision'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InvoiceInvoice
     */
    'lines'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof InvoiceInvoice
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof InvoiceInvoice
     */
    'metadata'?: object;
    /**
     * 
     * @type {number}
     * @memberof InvoiceInvoice
     */
    'next_payment_attempt'?: number;
    /**
     * 
     * @type {string}
     * @memberof InvoiceInvoice
     */
    'number'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceInvoice
     */
    'object'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InvoiceInvoice
     */
    'paid'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InvoiceInvoice
     */
    'paid_out_of_band'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InvoiceInvoice
     */
    'payment_intent'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceInvoice
     */
    'payment_settings'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceInvoice
     */
    'period_end'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceInvoice
     */
    'period_start'?: string;
    /**
     * 
     * @type {number}
     * @memberof InvoiceInvoice
     */
    'post_payment_credit_notes_amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof InvoiceInvoice
     */
    'pre_payment_credit_notes_amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof InvoiceInvoice
     */
    'price'?: string;
    /**
     * 
     * @type {number}
     * @memberof InvoiceInvoice
     */
    'quantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof InvoiceInvoice
     */
    'receipt_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceInvoice
     */
    'rendering_options'?: string;
    /**
     * 
     * @type {number}
     * @memberof InvoiceInvoice
     */
    'starting_balance'?: number;
    /**
     * 
     * @type {string}
     * @memberof InvoiceInvoice
     */
    'statement_descriptor'?: string;
    /**
     * 
     * @type {InvoiceStatus}
     * @memberof InvoiceInvoice
     */
    'status'?: InvoiceStatus;
    /**
     * 
     * @type {string}
     * @memberof InvoiceInvoice
     */
    'status_transitions'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceInvoice
     */
    'subscription'?: string;
    /**
     * 
     * @type {number}
     * @memberof InvoiceInvoice
     */
    'subscription_proration_date'?: number;
    /**
     * 
     * @type {number}
     * @memberof InvoiceInvoice
     */
    'subtotal'?: number;
    /**
     * 
     * @type {number}
     * @memberof InvoiceInvoice
     */
    'subtotal_excluding_tax'?: number;
    /**
     * 
     * @type {number}
     * @memberof InvoiceInvoice
     */
    'tax'?: number;
    /**
     * 
     * @type {string}
     * @memberof InvoiceInvoice
     */
    'threshold_reason'?: string;
    /**
     * 
     * @type {number}
     * @memberof InvoiceInvoice
     */
    'total'?: number;
    /**
     * 
     * @type {number}
     * @memberof InvoiceInvoice
     */
    'total_excluding_tax'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof InvoiceInvoice
     */
    'total_tax_amounts'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof InvoiceInvoice
     */
    'updated_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof InvoiceInvoice
     */
    'webhooks_delivered_at'?: number;
}


/**
 * 
 * @export
 * @interface InvoiceItemInvoiceitem
 */
export interface InvoiceItemInvoiceitem {
    /**
     * Amount (in the `currency` specified) of the invoice item. This should always be equal to `unit_amount * quantity`.
     * @type {number}
     * @memberof InvoiceItemInvoiceitem
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItemInvoiceitem
     */
    'created_at'?: string;
    /**
     * Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
     * @type {string}
     * @memberof InvoiceItemInvoiceitem
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItemInvoiceitem
     */
    'customer'?: string;
    /**
     * Time at which the object was created. Measured in seconds since the Unix epoch.
     * @type {number}
     * @memberof InvoiceItemInvoiceitem
     */
    'date'?: number;
    /**
     * 
     * @type {DatabaseDeletedAt}
     * @memberof InvoiceItemInvoiceitem
     */
    'deleted_at'?: DatabaseDeletedAt;
    /**
     * An arbitrary string attached to the object. Often useful for displaying to users.
     * @type {string}
     * @memberof InvoiceItemInvoiceitem
     */
    'description'?: string;
    /**
     * If true, discounts will apply to this invoice item. Always false for prorations.
     * @type {boolean}
     * @memberof InvoiceItemInvoiceitem
     */
    'discountable'?: boolean;
    /**
     * The discounts which apply to the invoice item. Item discounts are applied before invoice discounts. Use `expand[]=discounts` to expand each discount.
     * @type {Array<string>}
     * @memberof InvoiceItemInvoiceitem
     */
    'discounts'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItemInvoiceitem
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItemInvoiceitem
     */
    'invoice'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InvoiceItemInvoiceitem
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof InvoiceItemInvoiceitem
     */
    'metadata'?: object;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItemInvoiceitem
     */
    'object'?: string;
    /**
     * Unique identifier for the object.
     * @type {number}
     * @memberof InvoiceItemInvoiceitem
     */
    'period_end'?: number;
    /**
     * 
     * @type {number}
     * @memberof InvoiceItemInvoiceitem
     */
    'period_start'?: number;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItemInvoiceitem
     */
    'price'?: string;
    /**
     * Whether the invoice item was created automatically as a proration adjustment when the customer switched plans.
     * @type {boolean}
     * @memberof InvoiceItemInvoiceitem
     */
    'proration'?: boolean;
    /**
     * Quantity of units for the invoice item. If the invoice item is a proration, the quantity of the subscription that the proration was computed for.
     * @type {number}
     * @memberof InvoiceItemInvoiceitem
     */
    'quantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItemInvoiceitem
     */
    'subscription'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItemInvoiceitem
     */
    'subscription_item'?: string;
    /**
     * The tax rates which apply to the invoice item. When set, the `default_tax_rates` on the invoice do not apply to this invoice item.
     * @type {string}
     * @memberof InvoiceItemInvoiceitem
     */
    'tax_rates'?: string;
    /**
     * Unit amount (in the `currency` specified) of the invoice item.
     * @type {number}
     * @memberof InvoiceItemInvoiceitem
     */
    'unit_amount'?: number;
    /**
     * Same as `unit_amount`, but contains a decimal value with at most 12 decimal places.
     * @type {number}
     * @memberof InvoiceItemInvoiceitem
     */
    'unit_amount_decimal'?: number;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItemInvoiceitem
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const InvoiceStatus = {
    StatusDraft: 'draft',
    StatusOpen: 'open',
    StatusPaid: 'paid',
    StatusUncollectible: 'uncollectible',
    StatusVoid: 'void'
} as const;

export type InvoiceStatus = typeof InvoiceStatus[keyof typeof InvoiceStatus];


/**
 * 
 * @export
 * @interface ItemLineItem
 */
export interface ItemLineItem {
    /**
     * 
     * @type {number}
     * @memberof ItemLineItem
     */
    'amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemLineItem
     */
    'amount_excluding_tax'?: number;
    /**
     * 
     * @type {string}
     * @memberof ItemLineItem
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemLineItem
     */
    'currency'?: string;
    /**
     * 
     * @type {DatabaseDeletedAt}
     * @memberof ItemLineItem
     */
    'deleted_at'?: DatabaseDeletedAt;
    /**
     * 
     * @type {string}
     * @memberof ItemLineItem
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ItemLineItem
     */
    'discountable'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ItemLineItem
     */
    'discounts'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ItemLineItem
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ItemLineItem
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof ItemLineItem
     */
    'metadata'?: object;
    /**
     * 
     * @type {string}
     * @memberof ItemLineItem
     */
    'object'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemLineItem
     */
    'period_end'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemLineItem
     */
    'period_start'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemLineItem
     */
    'price'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemLineItem
     */
    'product'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ItemLineItem
     */
    'proration'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ItemLineItem
     */
    'proration_details'?: string;
    /**
     * 
     * @type {number}
     * @memberof ItemLineItem
     */
    'quantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof ItemLineItem
     */
    'subscription'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemLineItem
     */
    'subscription_item'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ItemLineItem
     */
    'tax_rates'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ItemLineItem
     */
    'type'?: string;
    /**
     * 
     * @type {number}
     * @memberof ItemLineItem
     */
    'unit_amount_excluding_tax'?: number;
    /**
     * 
     * @type {string}
     * @memberof ItemLineItem
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface LinkPaymentLink
 */
export interface LinkPaymentLink {
    /**
     * 
     * @type {boolean}
     * @memberof LinkPaymentLink
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof LinkPaymentLink
     */
    'after_completion'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof LinkPaymentLink
     */
    'allow_promotion_codes'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof LinkPaymentLink
     */
    'application_fee_amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof LinkPaymentLink
     */
    'application_fee_percent'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof LinkPaymentLink
     */
    'automatic_tax'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof LinkPaymentLink
     */
    'billing_address_collection'?: string;
    /**
     * 
     * @type {string}
     * @memberof LinkPaymentLink
     */
    'consent_collection'?: string;
    /**
     * 
     * @type {string}
     * @memberof LinkPaymentLink
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof LinkPaymentLink
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof LinkPaymentLink
     */
    'custom_text'?: string;
    /**
     * 
     * @type {string}
     * @memberof LinkPaymentLink
     */
    'customer_creation'?: string;
    /**
     * 
     * @type {DatabaseDeletedAt}
     * @memberof LinkPaymentLink
     */
    'deleted_at'?: DatabaseDeletedAt;
    /**
     * 
     * @type {string}
     * @memberof LinkPaymentLink
     */
    'id'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof LinkPaymentLink
     */
    'line_items'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof LinkPaymentLink
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof LinkPaymentLink
     */
    'metadata'?: object;
    /**
     * 
     * @type {string}
     * @memberof LinkPaymentLink
     */
    'object'?: string;
    /**
     * 
     * @type {string}
     * @memberof LinkPaymentLink
     */
    'payment_intent_data'?: string;
    /**
     * 
     * @type {string}
     * @memberof LinkPaymentLink
     */
    'payment_method_collection'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof LinkPaymentLink
     */
    'payment_method_types'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof LinkPaymentLink
     */
    'phone_number_collection'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof LinkPaymentLink
     */
    'shipping_address_collection'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof LinkPaymentLink
     */
    'shipping_options'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof LinkPaymentLink
     */
    'submit_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof LinkPaymentLink
     */
    'subscription_data'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof LinkPaymentLink
     */
    'tax_id_collection'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof LinkPaymentLink
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof LinkPaymentLink
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface MandateMandate
 */
export interface MandateMandate {
    /**
     * 
     * @type {string}
     * @memberof MandateMandate
     */
    'created_at'?: string;
    /**
     * 
     * @type {DatabaseDeletedAt}
     * @memberof MandateMandate
     */
    'deleted_at'?: DatabaseDeletedAt;
    /**
     * 
     * @type {string}
     * @memberof MandateMandate
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MandateMandate
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof MandateMandate
     */
    'metadata'?: object;
    /**
     * 
     * @type {string}
     * @memberof MandateMandate
     */
    'object'?: string;
    /**
     * 
     * @type {string}
     * @memberof MandateMandate
     */
    'payment_method'?: string;
    /**
     * 
     * @type {string}
     * @memberof MandateMandate
     */
    'payment_method_details'?: string;
    /**
     * 
     * @type {string}
     * @memberof MandateMandate
     */
    'single_use'?: string;
    /**
     * 
     * @type {MandateStatus}
     * @memberof MandateMandate
     */
    'status'?: MandateStatus;
    /**
     * 
     * @type {MandateType}
     * @memberof MandateMandate
     */
    'type'?: MandateType;
    /**
     * 
     * @type {string}
     * @memberof MandateMandate
     */
    'updated_at'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const MandateStatus = {
    StatusActive: 'active',
    StatusInactive: 'inactive',
    StatusPending: 'pending'
} as const;

export type MandateStatus = typeof MandateStatus[keyof typeof MandateStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const MandateType = {
    TypeMultiUse: 'multi_use',
    TypeSingleUse: 'single_use'
} as const;

export type MandateType = typeof MandateType[keyof typeof MandateType];


/**
 * 
 * @export
 * @interface MethodPaymentMethod
 */
export interface MethodPaymentMethod {
    /**
     * 
     * @type {string}
     * @memberof MethodPaymentMethod
     */
    'acss_debit'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodPaymentMethod
     */
    'affirm'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodPaymentMethod
     */
    'afterpay_clearpay'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodPaymentMethod
     */
    'alipay'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodPaymentMethod
     */
    'au_becs_debit'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodPaymentMethod
     */
    'bacs_debit'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodPaymentMethod
     */
    'bancontact'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodPaymentMethod
     */
    'billing_details'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodPaymentMethod
     */
    'blik'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodPaymentMethod
     */
    'boleto'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodPaymentMethod
     */
    'btc_pay'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodPaymentMethod
     */
    'card'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodPaymentMethod
     */
    'card_present'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodPaymentMethod
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodPaymentMethod
     */
    'customer'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodPaymentMethod
     */
    'customer_balance'?: string;
    /**
     * 
     * @type {DatabaseDeletedAt}
     * @memberof MethodPaymentMethod
     */
    'deleted_at'?: DatabaseDeletedAt;
    /**
     * 
     * @type {string}
     * @memberof MethodPaymentMethod
     */
    'eps'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodPaymentMethod
     */
    'fpx'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodPaymentMethod
     */
    'giropay'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodPaymentMethod
     */
    'grabpay'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodPaymentMethod
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodPaymentMethod
     */
    'ideal'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodPaymentMethod
     */
    'interac_present'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodPaymentMethod
     */
    'klarna'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodPaymentMethod
     */
    'konbini'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodPaymentMethod
     */
    'link'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MethodPaymentMethod
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof MethodPaymentMethod
     */
    'metadata'?: object;
    /**
     * 
     * @type {string}
     * @memberof MethodPaymentMethod
     */
    'object'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodPaymentMethod
     */
    'oxxo'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodPaymentMethod
     */
    'p24'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodPaymentMethod
     */
    'paynow'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodPaymentMethod
     */
    'pix'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodPaymentMethod
     */
    'promptpay'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodPaymentMethod
     */
    'radar_options'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodPaymentMethod
     */
    'sepa_debit'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodPaymentMethod
     */
    'sofort'?: string;
    /**
     * 
     * @type {MethodType}
     * @memberof MethodPaymentMethod
     */
    'type'?: MethodType;
    /**
     * 
     * @type {string}
     * @memberof MethodPaymentMethod
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodPaymentMethod
     */
    'us_bank_account'?: string;
    /**
     * 
     * @type {string}
     * @memberof MethodPaymentMethod
     */
    'wechat_pay'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const MethodType = {
    TypeAcssDebit: 'acss_debit',
    TypeAffirm: 'affirm',
    TypeAfterpayClearpay: 'afterpay_clearpay',
    TypeAlipay: 'alipay',
    TypeAuBecsDebit: 'au_becs_debit',
    TypeBacsDebit: 'bacs_debit',
    TypeBancontact: 'bancontact',
    TypeBlik: 'blik',
    TypeBoleto: 'boleto',
    TypeBtcpay: 'btcpay',
    TypeCard: 'card',
    TypeCardPresent: 'card_present',
    TypeCustomerBalance: 'customer_balance',
    TypeEps: 'eps',
    TypeFpx: 'fpx',
    TypeGiropay: 'giropay',
    TypeGrabpay: 'grabpay',
    TypeIdeal: 'ideal',
    TypeInteracPresent: 'interac_present',
    TypeKlarna: 'klarna',
    TypeKonbini: 'konbini',
    TypeLink: 'link',
    TypeOxxo: 'oxxo',
    TypeP24: 'p24',
    TypePaynow: 'paynow',
    TypePix: 'pix',
    TypePromptpay: 'promptpay',
    TypeSepaDebit: 'sepa_debit',
    TypeSofort: 'sofort',
    TypeUsBankAccount: 'us_bank_account',
    TypeWechatPay: 'wechat_pay'
} as const;

export type MethodType = typeof MethodType[keyof typeof MethodType];


/**
 * 
 * @export
 * @enum {string}
 */

export const PayoutMethod = {
    MethodStandard: 'standard',
    MethodInstant: 'instant'
} as const;

export type PayoutMethod = typeof PayoutMethod[keyof typeof PayoutMethod];


/**
 * 
 * @export
 * @interface PayoutPayout
 */
export interface PayoutPayout {
    /**
     * 
     * @type {number}
     * @memberof PayoutPayout
     */
    'amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof PayoutPayout
     */
    'arrival_date'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PayoutPayout
     */
    'automatic'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PayoutPayout
     */
    'balance_transaction'?: string;
    /**
     * 
     * @type {string}
     * @memberof PayoutPayout
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PayoutPayout
     */
    'currency'?: string;
    /**
     * 
     * @type {DatabaseDeletedAt}
     * @memberof PayoutPayout
     */
    'deleted_at'?: DatabaseDeletedAt;
    /**
     * 
     * @type {string}
     * @memberof PayoutPayout
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof PayoutPayout
     */
    'destination'?: string;
    /**
     * 
     * @type {string}
     * @memberof PayoutPayout
     */
    'failure_balance_transaction'?: string;
    /**
     * 
     * @type {string}
     * @memberof PayoutPayout
     */
    'failure_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof PayoutPayout
     */
    'failure_message'?: string;
    /**
     * 
     * @type {string}
     * @memberof PayoutPayout
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PayoutPayout
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof PayoutPayout
     */
    'metadata'?: object;
    /**
     * 
     * @type {PayoutMethod}
     * @memberof PayoutPayout
     */
    'method'?: PayoutMethod;
    /**
     * 
     * @type {string}
     * @memberof PayoutPayout
     */
    'object'?: string;
    /**
     * 
     * @type {string}
     * @memberof PayoutPayout
     */
    'original_payout'?: string;
    /**
     * 
     * @type {string}
     * @memberof PayoutPayout
     */
    'reversed_by'?: string;
    /**
     * 
     * @type {PayoutSourceType}
     * @memberof PayoutPayout
     */
    'source_type'?: PayoutSourceType;
    /**
     * 
     * @type {string}
     * @memberof PayoutPayout
     */
    'statement_descriptor'?: string;
    /**
     * 
     * @type {PayoutStatus}
     * @memberof PayoutPayout
     */
    'status'?: PayoutStatus;
    /**
     * 
     * @type {PayoutType}
     * @memberof PayoutPayout
     */
    'type'?: PayoutType;
    /**
     * 
     * @type {string}
     * @memberof PayoutPayout
     */
    'updated_at'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const PayoutSourceType = {
    SourceTypeCard: 'card',
    SourceTypeFpx: 'fpx',
    SourceTypeBankAccount: 'bank_account'
} as const;

export type PayoutSourceType = typeof PayoutSourceType[keyof typeof PayoutSourceType];


/**
 * 
 * @export
 * @enum {string}
 */

export const PayoutStatus = {
    StatusPaid: 'paid',
    StatusPending: 'pending',
    StatusInTransit: 'in_transit',
    StatusCanceled: 'canceled',
    StatusFailed: 'failed'
} as const;

export type PayoutStatus = typeof PayoutStatus[keyof typeof PayoutStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const PayoutType = {
    TypeBankAccount: 'bank_account',
    TypeCard: 'card'
} as const;

export type PayoutType = typeof PayoutType[keyof typeof PayoutType];


/**
 * 
 * @export
 * @interface PlanPlan
 */
export interface PlanPlan {
    /**
     * Whether the plan can be used for new purchases.
     * @type {boolean}
     * @memberof PlanPlan
     */
    'active'?: boolean;
    /**
     * Specifies a usage aggregation strategy for plans of `usage_type=metered`. Allowed values are `sum` for summing up all usage during a period, `last_during_period` for using the last usage record reported within a period, `last_ever` for using the last usage record ever (across period bounds) or `max` which uses the usage record with the maximum reported usage during a period. Defaults to `sum`.
     * @type {string}
     * @memberof PlanPlan
     */
    'aggregate_usage'?: string;
    /**
     * The unit amount in %s to be charged, represented as a whole integer if possible. Only set if `billing_scheme=per_unit`.
     * @type {number}
     * @memberof PlanPlan
     */
    'amount'?: number;
    /**
     * The unit amount in %s to be charged, represented as a decimal string with at most 12 decimal places. Only set if `billing_scheme=per_unit`.
     * @type {number}
     * @memberof PlanPlan
     */
    'amount_decimal'?: number;
    /**
     * Describes how to compute the price per period. Either `per_unit` or `tiered`. `per_unit` indicates that the fixed amount (specified in `amount`) will be charged per unit in `quantity` (for plans with `usage_type=licensed`), or per unit of total usage (for plans with `usage_type=metered`). `tiered` indicates that the unit pricing will be computed using a tiering strategy as defined using the `tiers` and `tiers_mode` attributes.
     * @type {string}
     * @memberof PlanPlan
     */
    'billing_scheme'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlanPlan
     */
    'created_at'?: string;
    /**
     * Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
     * @type {string}
     * @memberof PlanPlan
     */
    'currency'?: string;
    /**
     * 
     * @type {DatabaseDeletedAt}
     * @memberof PlanPlan
     */
    'deleted_at'?: DatabaseDeletedAt;
    /**
     * 
     * @type {string}
     * @memberof PlanPlan
     */
    'id'?: string;
    /**
     * The frequency at which a subscription is billed. One of `day`, `week`, `month` or `year`.
     * @type {string}
     * @memberof PlanPlan
     */
    'interval'?: string;
    /**
     * The number of intervals (specified in the `interval` attribute) between subscription billings. For example, `interval=month` and `interval_count=3` bills every 3 months.
     * @type {number}
     * @memberof PlanPlan
     */
    'interval_count'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PlanPlan
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof PlanPlan
     */
    'metadata'?: object;
    /**
     * A brief description of the plan, hidden from customers.
     * @type {string}
     * @memberof PlanPlan
     */
    'nickname'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlanPlan
     */
    'object'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlanPlan
     */
    'product'?: string;
    /**
     * Each element represents a pricing tier. This parameter requires `billing_scheme` to be set to `tiered`. See also the documentation for `billing_scheme`.
     * @type {Array<string>}
     * @memberof PlanPlan
     */
    'tiers'?: Array<string>;
    /**
     * Defines if the tiering price should be `graduated` or `volume` based. In `volume`-based tiering, the maximum quantity within a period determines the per unit price. In `graduated` tiering, pricing can change as the quantity grows.
     * @type {string}
     * @memberof PlanPlan
     */
    'tiers_mode'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlanPlan
     */
    'transform_usage'?: string;
    /**
     * Default number of trial days when subscribing a customer to this plan using [`trial_from_plan=true`](https://stripe.com/docs/api#create_subscription-trial_from_plan).
     * @type {number}
     * @memberof PlanPlan
     */
    'trial_period_days'?: number;
    /**
     * 
     * @type {string}
     * @memberof PlanPlan
     */
    'updated_at'?: string;
    /**
     * Configures how the quantity per period should be determined. Can be either `metered` or `licensed`. `licensed` automatically bills the `quantity` set when adding it to a subscription. `metered` aggregates the total usage based on usage records. Defaults to `licensed`.
     * @type {string}
     * @memberof PlanPlan
     */
    'usage_type'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PriceBillingScheme = {
    BillingSchemePerUnit: 'per_unit',
    BillingSchemeTiered: 'tiered'
} as const;

export type PriceBillingScheme = typeof PriceBillingScheme[keyof typeof PriceBillingScheme];


/**
 * 
 * @export
 * @interface PricePrice
 */
export interface PricePrice {
    /**
     * 
     * @type {boolean}
     * @memberof PricePrice
     */
    'active'?: boolean;
    /**
     * 
     * @type {PriceBillingScheme}
     * @memberof PricePrice
     */
    'billing_scheme'?: PriceBillingScheme;
    /**
     * 
     * @type {string}
     * @memberof PricePrice
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PricePrice
     */
    'currency'?: string;
    /**
     * 
     * @type {DatabaseDeletedAt}
     * @memberof PricePrice
     */
    'deleted_at'?: DatabaseDeletedAt;
    /**
     * 
     * @type {string}
     * @memberof PricePrice
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PricePrice
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PricePrice
     */
    'lookup_key'?: string;
    /**
     * 
     * @type {object}
     * @memberof PricePrice
     */
    'metadata'?: object;
    /**
     * 
     * @type {string}
     * @memberof PricePrice
     */
    'nickname'?: string;
    /**
     * 
     * @type {string}
     * @memberof PricePrice
     */
    'object'?: string;
    /**
     * 
     * @type {string}
     * @memberof PricePrice
     */
    'product'?: string;
    /**
     * 
     * @type {string}
     * @memberof PricePrice
     */
    'recurring'?: string;
    /**
     * 
     * @type {PriceTaxBehavior}
     * @memberof PricePrice
     */
    'tax_behavior'?: PriceTaxBehavior;
    /**
     * 
     * @type {Array<string>}
     * @memberof PricePrice
     */
    'tiers'?: Array<string>;
    /**
     * 
     * @type {PriceTiersMode}
     * @memberof PricePrice
     */
    'tiers_mode'?: PriceTiersMode;
    /**
     * 
     * @type {string}
     * @memberof PricePrice
     */
    'transform_quantity'?: string;
    /**
     * 
     * @type {PriceType}
     * @memberof PricePrice
     */
    'type'?: PriceType;
    /**
     * 
     * @type {number}
     * @memberof PricePrice
     */
    'unit_amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof PricePrice
     */
    'unit_amount_decimal'?: number;
    /**
     * 
     * @type {string}
     * @memberof PricePrice
     */
    'updated_at'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const PriceTaxBehavior = {
    TaxBehaviorInclusive: 'inclusive',
    TaxBehaviorExclusive: 'exclusive',
    TaxBehaviorUnspecified: 'unspecified'
} as const;

export type PriceTaxBehavior = typeof PriceTaxBehavior[keyof typeof PriceTaxBehavior];


/**
 * 
 * @export
 * @enum {string}
 */

export const PriceTiersMode = {
    TiersModeGraduated: 'graduated',
    TiersModeVolume: 'volume'
} as const;

export type PriceTiersMode = typeof PriceTiersMode[keyof typeof PriceTiersMode];


/**
 * 
 * @export
 * @enum {string}
 */

export const PriceType = {
    TypeOneTime: 'one_time',
    TypeRecurring: 'recurring'
} as const;

export type PriceType = typeof PriceType[keyof typeof PriceType];


/**
 * 
 * @export
 * @interface ProductProduct
 */
export interface ProductProduct {
    /**
     * 
     * @type {boolean}
     * @memberof ProductProduct
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProductProduct
     */
    'created_at'?: string;
    /**
     * 
     * @type {DatabaseDeletedAt}
     * @memberof ProductProduct
     */
    'deleted_at'?: DatabaseDeletedAt;
    /**
     * 
     * @type {string}
     * @memberof ProductProduct
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductProduct
     */
    'id'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProductProduct
     */
    'images'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof ProductProduct
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof ProductProduct
     */
    'metadata'?: object;
    /**
     * 
     * @type {string}
     * @memberof ProductProduct
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductProduct
     */
    'object'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductProduct
     */
    'package_dimensions'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProductProduct
     */
    'shippable'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProductProduct
     */
    'statement_descriptor'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductProduct
     */
    'tax_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductProduct
     */
    'unit_label'?: string;
    /**
     * 
     * @type {number}
     * @memberof ProductProduct
     */
    'updated'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductProduct
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductProduct
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface PromotionPromotionCode
 */
export interface PromotionPromotionCode {
    /**
     * 
     * @type {boolean}
     * @memberof PromotionPromotionCode
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PromotionPromotionCode
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof PromotionPromotionCode
     */
    'coupon'?: string;
    /**
     * 
     * @type {string}
     * @memberof PromotionPromotionCode
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PromotionPromotionCode
     */
    'customer'?: string;
    /**
     * 
     * @type {DatabaseDeletedAt}
     * @memberof PromotionPromotionCode
     */
    'deleted_at'?: DatabaseDeletedAt;
    /**
     * 
     * @type {number}
     * @memberof PromotionPromotionCode
     */
    'expires_at'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PromotionPromotionCode
     */
    'first_time_transaction'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PromotionPromotionCode
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PromotionPromotionCode
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PromotionPromotionCode
     */
    'max_redemptions'?: number;
    /**
     * 
     * @type {object}
     * @memberof PromotionPromotionCode
     */
    'metadata'?: object;
    /**
     * 
     * @type {number}
     * @memberof PromotionPromotionCode
     */
    'minimum_amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof PromotionPromotionCode
     */
    'minimum_amount_currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof PromotionPromotionCode
     */
    'object'?: string;
    /**
     * 
     * @type {number}
     * @memberof PromotionPromotionCode
     */
    'times_redeemed'?: number;
    /**
     * 
     * @type {string}
     * @memberof PromotionPromotionCode
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface QuoteQuote
 */
export interface QuoteQuote {
    /**
     * Total before any discounts or taxes are applied.
     * @type {number}
     * @memberof QuoteQuote
     */
    'amount_subtotal'?: number;
    /**
     * Total after discounts and taxes are applied.
     * @type {number}
     * @memberof QuoteQuote
     */
    'amount_total'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof QuoteQuote
     */
    'automatic_tax'?: boolean;
    /**
     * Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay invoices at the end of the subscription cycle or on finalization using the default payment method attached to the subscription or customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions and mark the subscription as `active`. Defaults to `charge_automatically`.
     * @type {string}
     * @memberof QuoteQuote
     */
    'collection_method'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuoteQuote
     */
    'computed'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuoteQuote
     */
    'created_at'?: string;
    /**
     * Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
     * @type {string}
     * @memberof QuoteQuote
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuoteQuote
     */
    'customer'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof QuoteQuote
     */
    'default_tax_rates'?: Array<string>;
    /**
     * 
     * @type {DatabaseDeletedAt}
     * @memberof QuoteQuote
     */
    'deleted_at'?: DatabaseDeletedAt;
    /**
     * A description that will be displayed on the quote PDF.
     * @type {string}
     * @memberof QuoteQuote
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof QuoteQuote
     */
    'discounts'?: Array<string>;
    /**
     * The date on which the quote will be canceled if in `open` or `draft` status. Measured in seconds since the Unix epoch.
     * @type {number}
     * @memberof QuoteQuote
     */
    'expires_at'?: number;
    /**
     * A footer that will be displayed on the quote PDF.
     * @type {string}
     * @memberof QuoteQuote
     */
    'footer'?: string;
    /**
     * A header that will be displayed on the quote PDF.
     * @type {string}
     * @memberof QuoteQuote
     */
    'header'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuoteQuote
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuoteQuote
     */
    'invoice'?: string;
    /**
     * Unique identifier for the object.
     * @type {string}
     * @memberof QuoteQuote
     */
    'invoice_settings'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof QuoteQuote
     */
    'line_items'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof QuoteQuote
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof QuoteQuote
     */
    'metadata'?: object;
    /**
     * A unique number that identifies this particular quote. This number is assigned once the quote is [finalized](https://stripe.com/docs/quotes/overview#finalize).
     * @type {string}
     * @memberof QuoteQuote
     */
    'number'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuoteQuote
     */
    'object'?: string;
    /**
     * The status of the quote.
     * @type {string}
     * @memberof QuoteQuote
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuoteQuote
     */
    'status_transitions'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuoteQuote
     */
    'subscription'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuoteQuote
     */
    'subscription_data'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuoteQuote
     */
    'subscription_schedule'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuoteQuote
     */
    'total_details'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuoteQuote
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const RefundFailureReason = {
    FailureReasonLostOrStolenCard: 'lost_or_stolen_card',
    FailureReasonExpiredOrCanceledCard: 'expired_or_canceled_card',
    FailureReasonUnknown: 'unknown'
} as const;

export type RefundFailureReason = typeof RefundFailureReason[keyof typeof RefundFailureReason];


/**
 * 
 * @export
 * @enum {string}
 */

export const RefundReason = {
    ReasonDuplicate: 'duplicate',
    ReasonFraudulent: 'fraudulent',
    ReasonRequestedByCustomer: 'requested_by_customer',
    ReasonExpiredUncapturedCharge: 'expired_uncaptured_charge'
} as const;

export type RefundReason = typeof RefundReason[keyof typeof RefundReason];


/**
 * 
 * @export
 * @interface RefundRefund
 */
export interface RefundRefund {
    /**
     * 
     * @type {number}
     * @memberof RefundRefund
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof RefundRefund
     */
    'balance_transaction'?: string;
    /**
     * 
     * @type {string}
     * @memberof RefundRefund
     */
    'charge'?: string;
    /**
     * 
     * @type {string}
     * @memberof RefundRefund
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof RefundRefund
     */
    'currency'?: string;
    /**
     * 
     * @type {DatabaseDeletedAt}
     * @memberof RefundRefund
     */
    'deleted_at'?: DatabaseDeletedAt;
    /**
     * 
     * @type {string}
     * @memberof RefundRefund
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof RefundRefund
     */
    'failure_balance_transaction'?: string;
    /**
     * 
     * @type {RefundFailureReason}
     * @memberof RefundRefund
     */
    'failure_reason'?: RefundFailureReason;
    /**
     * 
     * @type {string}
     * @memberof RefundRefund
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof RefundRefund
     */
    'instructions_email'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RefundRefund
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof RefundRefund
     */
    'metadata'?: object;
    /**
     * 
     * @type {string}
     * @memberof RefundRefund
     */
    'next_action'?: string;
    /**
     * 
     * @type {string}
     * @memberof RefundRefund
     */
    'object'?: string;
    /**
     * 
     * @type {string}
     * @memberof RefundRefund
     */
    'payment_intent'?: string;
    /**
     * 
     * @type {RefundReason}
     * @memberof RefundRefund
     */
    'reason'?: RefundReason;
    /**
     * 
     * @type {string}
     * @memberof RefundRefund
     */
    'receipt_number'?: string;
    /**
     * 
     * @type {RefundStatus}
     * @memberof RefundRefund
     */
    'status'?: RefundStatus;
    /**
     * 
     * @type {string}
     * @memberof RefundRefund
     */
    'updated_at'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const RefundStatus = {
    StatusPending: 'pending',
    StatusRequiresAction: 'requires_action',
    StatusSucceeded: 'succeeded',
    StatusFailed: 'failed',
    StatusCanceled: 'canceled'
} as const;

export type RefundStatus = typeof RefundStatus[keyof typeof RefundStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const SourceFlow = {
    FlowRedirect: 'redirect',
    FlowReceiver: 'receiver',
    FlowCodeVerification: 'code_verification',
    FlowNone: 'none'
} as const;

export type SourceFlow = typeof SourceFlow[keyof typeof SourceFlow];


/**
 * 
 * @export
 * @interface SourceSource
 */
export interface SourceSource {
    /**
     * 
     * @type {string}
     * @memberof SourceSource
     */
    'ach_credit_transfer'?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceSource
     */
    'ach_debit'?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceSource
     */
    'acss_debit'?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceSource
     */
    'alipay'?: string;
    /**
     * 
     * @type {number}
     * @memberof SourceSource
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof SourceSource
     */
    'au_becs_debit'?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceSource
     */
    'bancontact'?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceSource
     */
    'card'?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceSource
     */
    'card_present'?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceSource
     */
    'client_secret'?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceSource
     */
    'code_verification'?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceSource
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceSource
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceSource
     */
    'customer'?: string;
    /**
     * 
     * @type {DatabaseDeletedAt}
     * @memberof SourceSource
     */
    'deleted_at'?: DatabaseDeletedAt;
    /**
     * 
     * @type {string}
     * @memberof SourceSource
     */
    'eps'?: string;
    /**
     * 
     * @type {SourceFlow}
     * @memberof SourceSource
     */
    'flow'?: SourceFlow;
    /**
     * 
     * @type {string}
     * @memberof SourceSource
     */
    'giropay'?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceSource
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceSource
     */
    'ideal'?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceSource
     */
    'klarna'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SourceSource
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof SourceSource
     */
    'metadata'?: object;
    /**
     * 
     * @type {string}
     * @memberof SourceSource
     */
    'multibanco'?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceSource
     */
    'object'?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceSource
     */
    'owner'?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceSource
     */
    'p24'?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceSource
     */
    'receiver'?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceSource
     */
    'redirect'?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceSource
     */
    'sepa_debit'?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceSource
     */
    'sofort'?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceSource
     */
    'source_order'?: string;
    /**
     * 
     * @type {string}
     * @memberof SourceSource
     */
    'statement_descriptor'?: string;
    /**
     * 
     * @type {SourceStatus}
     * @memberof SourceSource
     */
    'status'?: SourceStatus;
    /**
     * 
     * @type {string}
     * @memberof SourceSource
     */
    'three_d_secure'?: string;
    /**
     * 
     * @type {SourceType}
     * @memberof SourceSource
     */
    'type'?: SourceType;
    /**
     * 
     * @type {string}
     * @memberof SourceSource
     */
    'updated_at'?: string;
    /**
     * 
     * @type {SourceUsage}
     * @memberof SourceSource
     */
    'usage'?: SourceUsage;
    /**
     * 
     * @type {string}
     * @memberof SourceSource
     */
    'wechat'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const SourceStatus = {
    StatusCanceled: 'canceled',
    StatusChargeable: 'chargeable',
    StatusConsumed: 'consumed',
    StatusFailed: 'failed',
    StatusPending: 'pending'
} as const;

export type SourceStatus = typeof SourceStatus[keyof typeof SourceStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const SourceType = {
    TypeAchreusableTransfer: 'ach_reusable_transfer',
    TypeAchDebit: 'ach_debit',
    TypeAlipay: 'alipay',
    TypeBancontact: 'bancontact',
    TypeCard: 'card',
    TypeCardPresent: 'card_present',
    TypeEps: 'eps',
    TypeGiropay: 'giropay',
    TypeIdeal: 'ideal',
    TypeMultibanco: 'multibanco',
    TypeKlarna: 'klarna',
    TypeP24: 'p24',
    TypeSepaDebit: 'sepa_debit',
    TypeSofort: 'sofort',
    TypeThreeDSecure: 'three_d_secure',
    TypeWechat: 'wechat'
} as const;

export type SourceType = typeof SourceType[keyof typeof SourceType];


/**
 * 
 * @export
 * @enum {string}
 */

export const SourceUsage = {
    UsageReusable: 'reusable',
    UsageSingleUse: 'single_use'
} as const;

export type SourceUsage = typeof SourceUsage[keyof typeof SourceUsage];


/**
 * 
 * @export
 * @interface SubscriptionItemSubscriptionItem
 */
export interface SubscriptionItemSubscriptionItem {
    /**
     * 
     * @type {string}
     * @memberof SubscriptionItemSubscriptionItem
     */
    'created_at'?: string;
    /**
     * 
     * @type {DatabaseDeletedAt}
     * @memberof SubscriptionItemSubscriptionItem
     */
    'deleted_at'?: DatabaseDeletedAt;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionItemSubscriptionItem
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SubscriptionItemSubscriptionItem
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof SubscriptionItemSubscriptionItem
     */
    'metadata'?: object;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionItemSubscriptionItem
     */
    'object'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionItemSubscriptionItem
     */
    'price'?: string;
    /**
     * The [quantity](https://stripe.com/docs/subscriptions/quantities) of the plan to which the customer should be subscribed.
     * @type {number}
     * @memberof SubscriptionItemSubscriptionItem
     */
    'quantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionItemSubscriptionItem
     */
    'subscription'?: string;
    /**
     * The tax rates which apply to this `subscription_item`. When set, the `default_tax_rates` on the subscription do not apply to this `subscription_item`.
     * @type {string}
     * @memberof SubscriptionItemSubscriptionItem
     */
    'tax_rates'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionItemSubscriptionItem
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface SubscriptionScheduleSubscriptionSchedule
 */
export interface SubscriptionScheduleSubscriptionSchedule {
    /**
     * Time at which the subscription schedule was canceled. Measured in seconds since the Unix epoch.
     * @type {number}
     * @memberof SubscriptionScheduleSubscriptionSchedule
     */
    'canceled_at'?: number;
    /**
     * Time at which the subscription schedule was completed. Measured in seconds since the Unix epoch.
     * @type {number}
     * @memberof SubscriptionScheduleSubscriptionSchedule
     */
    'completed_at'?: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionScheduleSubscriptionSchedule
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionScheduleSubscriptionSchedule
     */
    'customer'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionScheduleSubscriptionSchedule
     */
    'default_settings'?: string;
    /**
     * 
     * @type {DatabaseDeletedAt}
     * @memberof SubscriptionScheduleSubscriptionSchedule
     */
    'deleted_at'?: DatabaseDeletedAt;
    /**
     * Behavior of the subscription schedule and underlying subscription when it ends. Possible values are `release` or `cancel` with the default being `release`. `release` will end the subscription schedule and keep the underlying subscription running.`cancel` will end the subscription schedule and cancel the underlying subscription.
     * @type {string}
     * @memberof SubscriptionScheduleSubscriptionSchedule
     */
    'end_behavior'?: string;
    /**
     * The end of this phase of the subscription schedule.
     * @type {number}
     * @memberof SubscriptionScheduleSubscriptionSchedule
     */
    'end_date'?: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionScheduleSubscriptionSchedule
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SubscriptionScheduleSubscriptionSchedule
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof SubscriptionScheduleSubscriptionSchedule
     */
    'metadata'?: object;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionScheduleSubscriptionSchedule
     */
    'object'?: string;
    /**
     * Configuration for the subscription schedule\'s phases.
     * @type {string}
     * @memberof SubscriptionScheduleSubscriptionSchedule
     */
    'phases'?: string;
    /**
     * Time at which the subscription schedule was released. Measured in seconds since the Unix epoch.
     * @type {string}
     * @memberof SubscriptionScheduleSubscriptionSchedule
     */
    'released_at'?: string;
    /**
     * ID of the subscription once managed by the subscription schedule (if it is released).
     * @type {string}
     * @memberof SubscriptionScheduleSubscriptionSchedule
     */
    'released_subscription'?: string;
    /**
     * The start of this phase of the subscription schedule.
     * @type {number}
     * @memberof SubscriptionScheduleSubscriptionSchedule
     */
    'start_date'?: number;
    /**
     * The present status of the subscription schedule. Possible values are `not_started`, `active`, `completed`, `released`, and `canceled`. You can read more about the different states in our [behavior guide](https://stripe.com/docs/billing/subscriptions/subscription-schedules).
     * @type {string}
     * @memberof SubscriptionScheduleSubscriptionSchedule
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionScheduleSubscriptionSchedule
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface SubscriptionSubscription
 */
export interface SubscriptionSubscription {
    /**
     * 
     * @type {boolean}
     * @memberof SubscriptionSubscription
     */
    'automatic_tax'?: boolean;
    /**
     * Determines the date of the first full invoice, and, for plans with `month` or `year` intervals, the day of the month for subsequent invoices. The timestamp is in UTC format.
     * @type {number}
     * @memberof SubscriptionSubscription
     */
    'billing_cycle_anchor'?: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionSubscription
     */
    'billing_thresholds'?: string;
    /**
     * A date in the future at which the subscription will automatically get canceled
     * @type {number}
     * @memberof SubscriptionSubscription
     */
    'cancel_at'?: number;
    /**
     * If the subscription has been canceled with the `at_period_end` flag set to `true`, `cancel_at_period_end` on the subscription will be true. You can use this attribute to determine whether a subscription that has a status of active is scheduled to be canceled at the end of the current period.
     * @type {boolean}
     * @memberof SubscriptionSubscription
     */
    'cancel_at_period_end'?: boolean;
    /**
     * If the subscription has been canceled, the date of that cancellation. If the subscription was canceled with `cancel_at_period_end`, `canceled_at` will reflect the time of the most recent update request, not the end of the subscription period when the subscription is automatically moved to a canceled state.
     * @type {number}
     * @memberof SubscriptionSubscription
     */
    'canceled_at'?: number;
    /**
     * Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will attempt to pay this subscription at the end of the cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions and mark the subscription as `active`.
     * @type {string}
     * @memberof SubscriptionSubscription
     */
    'collection_method'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionSubscription
     */
    'created_at'?: string;
    /**
     * Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
     * @type {string}
     * @memberof SubscriptionSubscription
     */
    'currency'?: string;
    /**
     * End of the current period that the subscription has been invoiced for. At the end of this period, a new invoice will be created.
     * @type {number}
     * @memberof SubscriptionSubscription
     */
    'current_period_end'?: number;
    /**
     * Start of the current period that the subscription has been invoiced for.
     * @type {number}
     * @memberof SubscriptionSubscription
     */
    'current_period_start'?: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionSubscription
     */
    'customer'?: string;
    /**
     * Number of days a customer has to pay invoices generated by this subscription. This value will be `null` for subscriptions where `collection_method=charge_automatically`.
     * @type {number}
     * @memberof SubscriptionSubscription
     */
    'days_until_due'?: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionSubscription
     */
    'default_payment_method'?: string;
    /**
     * The tax rates that will apply to any subscription item that does not have `tax_rates` set. Invoices created will have their `default_tax_rates` populated from the subscription.
     * @type {string}
     * @memberof SubscriptionSubscription
     */
    'default_tax_rates'?: string;
    /**
     * 
     * @type {DatabaseDeletedAt}
     * @memberof SubscriptionSubscription
     */
    'deleted_at'?: DatabaseDeletedAt;
    /**
     * The subscription\'s description, meant to be displayable to the customer. Use this field to optionally store an explanation of the subscription for rendering in Stripe surfaces.
     * @type {string}
     * @memberof SubscriptionSubscription
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionSubscription
     */
    'discount'?: string;
    /**
     * If the subscription has ended, the date the subscription ended.
     * @type {number}
     * @memberof SubscriptionSubscription
     */
    'ended_at'?: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionSubscription
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SubscriptionSubscription
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof SubscriptionSubscription
     */
    'metadata'?: object;
    /**
     * Specifies the approximate timestamp on which any pending invoice items will be billed according to the schedule provided at `pending_invoice_item_interval`.
     * @type {number}
     * @memberof SubscriptionSubscription
     */
    'next_pending_invoice_item_invoice'?: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionSubscription
     */
    'object'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionSubscription
     */
    'pause_collection'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionSubscription
     */
    'payment_settings'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionSubscription
     */
    'pending_invoice_item_interval'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionSubscription
     */
    'pending_setup_intent'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionSubscription
     */
    'pending_update'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionSubscription
     */
    'price'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionSubscription
     */
    'schedule'?: string;
    /**
     * Date when the subscription was first created. The date might differ from the `created` date due to backdating.
     * @type {number}
     * @memberof SubscriptionSubscription
     */
    'start_date'?: number;
    /**
     * Possible values are `incomplete`, `incomplete_expired`, `trialing`, `active`, `past_due`, `canceled`, or `unpaid`.   For `collection_method=charge_automatically` a subscription moves into `incomplete` if the initial payment attempt fails. A subscription in this state can only have metadata and default_source updated. Once the first invoice is paid, the subscription moves into an `active` state. If the first invoice is not paid within 23 hours, the subscription transitions to `incomplete_expired`. This is a terminal state, the open invoice will be voided and no further invoices will be generated.   A subscription that is currently in a trial period is `trialing` and moves to `active` when the trial period is over.   If subscription `collection_method=charge_automatically` it becomes `past_due` when payment to renew it fails and `canceled` or `unpaid` (depending on your subscriptions settings) when Stripe has exhausted all payment retry attempts.   If subscription `collection_method=send_invoice` it becomes `past_due` when its invoice is not paid by the due date, and `canceled` or `unpaid` if it is still not paid by an additional deadline after that. Note that when a subscription has a status of `unpaid`, no subsequent invoices will be attempted (invoices will be created, but then immediately automatically closed). After receiving updated payment information from a customer, you may choose to reopen and pay their closed invoices.
     * @type {string}
     * @memberof SubscriptionSubscription
     */
    'status'?: string;
    /**
     * If the subscription has a trial, the end of that trial.
     * @type {number}
     * @memberof SubscriptionSubscription
     */
    'trial_end'?: number;
    /**
     * If the subscription has a trial, the beginning of that trial.
     * @type {number}
     * @memberof SubscriptionSubscription
     */
    'trial_start'?: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionSubscription
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface UsageRecordUsageRecord
 */
export interface UsageRecordUsageRecord {
    /**
     * 
     * @type {string}
     * @memberof UsageRecordUsageRecord
     */
    'created_at'?: string;
    /**
     * 
     * @type {DatabaseDeletedAt}
     * @memberof UsageRecordUsageRecord
     */
    'deleted_at'?: DatabaseDeletedAt;
    /**
     * 
     * @type {string}
     * @memberof UsageRecordUsageRecord
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UsageRecordUsageRecord
     */
    'livemode'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof UsageRecordUsageRecord
     */
    'metadata'?: object;
    /**
     * String representing the object\'s type. Objects of the same type share the same value.
     * @type {string}
     * @memberof UsageRecordUsageRecord
     */
    'object'?: string;
    /**
     * The usage quantity for the specified date.
     * @type {number}
     * @memberof UsageRecordUsageRecord
     */
    'quantity'?: number;
    /**
     * The ID of the subscription item this usage record contains data for.
     * @type {string}
     * @memberof UsageRecordUsageRecord
     */
    'subscription_item'?: string;
    /**
     * The timestamp when this usage occurred.
     * @type {number}
     * @memberof UsageRecordUsageRecord
     */
    'timestamp'?: number;
    /**
     * 
     * @type {string}
     * @memberof UsageRecordUsageRecord
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface UuidNullUUID
 */
export interface UuidNullUUID {
    /**
     * 
     * @type {string}
     * @memberof UuidNullUUID
     */
    'uuid'?: string;
    /**
     * Valid is true if UUID is not NULL
     * @type {boolean}
     * @memberof UuidNullUUID
     */
    'valid'?: boolean;
}

/**
 * BalanceApi - axios parameter creator
 * @export
 */
export const BalanceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get Balance by given ID or 404 error.
         * @summary get Balance by given ID or 404 error.
         * @param {string} id Balance ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1BalanceGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1BalanceGet', 'id', id)
            const localVarPath = `/v1/balance`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BalanceApi - functional programming interface
 * @export
 */
export const BalanceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BalanceApiAxiosParamCreator(configuration)
    return {
        /**
         * Get Balance by given ID or 404 error.
         * @summary get Balance by given ID or 404 error.
         * @param {string} id Balance ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1BalanceGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BalanceBalance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1BalanceGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BalanceApi - factory interface
 * @export
 */
export const BalanceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BalanceApiFp(configuration)
    return {
        /**
         * Get Balance by given ID or 404 error.
         * @summary get Balance by given ID or 404 error.
         * @param {string} id Balance ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1BalanceGet(id: string, options?: any): AxiosPromise<BalanceBalance> {
            return localVarFp.v1BalanceGet(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BalanceApi - object-oriented interface
 * @export
 * @class BalanceApi
 * @extends {BaseAPI}
 */
export class BalanceApi extends BaseAPI {
    /**
     * Get Balance by given ID or 404 error.
     * @summary get Balance by given ID or 404 error.
     * @param {string} id Balance ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceApi
     */
    public v1BalanceGet(id: string, options?: AxiosRequestConfig) {
        return BalanceApiFp(this.configuration).v1BalanceGet(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BalanceTransactionApi - axios parameter creator
 * @export
 */
export const BalanceTransactionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all existing BalanceTransaction.
         * @summary get all existing BalanceTransaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1BalanceTransactionsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/balance_transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get BalanceTransaction by given ID or 404 error.
         * @summary get BalanceTransaction by given ID or 404 error.
         * @param {string} id BalanceTransaction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1BalanceTransactionsIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1BalanceTransactionsIdGet', 'id', id)
            const localVarPath = `/v1/balance_transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BalanceTransactionApi - functional programming interface
 * @export
 */
export const BalanceTransactionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BalanceTransactionApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all existing BalanceTransaction.
         * @summary get all existing BalanceTransaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1BalanceTransactionsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BalanceBalanceTransaction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1BalanceTransactionsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get BalanceTransaction by given ID or 404 error.
         * @summary get BalanceTransaction by given ID or 404 error.
         * @param {string} id BalanceTransaction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1BalanceTransactionsIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BalanceBalanceTransaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1BalanceTransactionsIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BalanceTransactionApi - factory interface
 * @export
 */
export const BalanceTransactionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BalanceTransactionApiFp(configuration)
    return {
        /**
         * Get all existing BalanceTransaction.
         * @summary get all existing BalanceTransaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1BalanceTransactionsGet(options?: any): AxiosPromise<Array<BalanceBalanceTransaction>> {
            return localVarFp.v1BalanceTransactionsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get BalanceTransaction by given ID or 404 error.
         * @summary get BalanceTransaction by given ID or 404 error.
         * @param {string} id BalanceTransaction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1BalanceTransactionsIdGet(id: string, options?: any): AxiosPromise<BalanceBalanceTransaction> {
            return localVarFp.v1BalanceTransactionsIdGet(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BalanceTransactionApi - object-oriented interface
 * @export
 * @class BalanceTransactionApi
 * @extends {BaseAPI}
 */
export class BalanceTransactionApi extends BaseAPI {
    /**
     * Get all existing BalanceTransaction.
     * @summary get all existing BalanceTransaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceTransactionApi
     */
    public v1BalanceTransactionsGet(options?: AxiosRequestConfig) {
        return BalanceTransactionApiFp(this.configuration).v1BalanceTransactionsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get BalanceTransaction by given ID or 404 error.
     * @summary get BalanceTransaction by given ID or 404 error.
     * @param {string} id BalanceTransaction ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceTransactionApi
     */
    public v1BalanceTransactionsIdGet(id: string, options?: AxiosRequestConfig) {
        return BalanceTransactionApiFp(this.configuration).v1BalanceTransactionsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BankAccountApi - axios parameter creator
 * @export
 */
export const BankAccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Verify BankAccount.
         * @summary verify BankAccount
         * @param {string} id BankAccount ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersIdSourcesIdVerifyPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CustomersIdSourcesIdVerifyPost', 'id', id)
            const localVarPath = `/v1/customers/{id}/sources/{id}/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BankAccountApi - functional programming interface
 * @export
 */
export const BankAccountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BankAccountApiAxiosParamCreator(configuration)
    return {
        /**
         * Verify BankAccount.
         * @summary verify BankAccount
         * @param {string} id BankAccount ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CustomersIdSourcesIdVerifyPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankBankAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CustomersIdSourcesIdVerifyPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BankAccountApi - factory interface
 * @export
 */
export const BankAccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BankAccountApiFp(configuration)
    return {
        /**
         * Verify BankAccount.
         * @summary verify BankAccount
         * @param {string} id BankAccount ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersIdSourcesIdVerifyPost(id: string, options?: any): AxiosPromise<BankBankAccount> {
            return localVarFp.v1CustomersIdSourcesIdVerifyPost(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BankAccountApi - object-oriented interface
 * @export
 * @class BankAccountApi
 * @extends {BaseAPI}
 */
export class BankAccountApi extends BaseAPI {
    /**
     * Verify BankAccount.
     * @summary verify BankAccount
     * @param {string} id BankAccount ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankAccountApi
     */
    public v1CustomersIdSourcesIdVerifyPost(id: string, options?: AxiosRequestConfig) {
        return BankAccountApiFp(this.configuration).v1CustomersIdSourcesIdVerifyPost(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CardApi - axios parameter creator
 * @export
 */
export const CardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all existing Cards.
         * @summary get all existing Cards
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersIdSourcesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/customers/{id}/sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Card by given ID or 404 error.
         * @summary get Card by given ID or 404 error.
         * @param {string} id Card ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersIdSourcesIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CustomersIdSourcesIdGet', 'id', id)
            const localVarPath = `/v1/customers/{id}/sources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Card.
         * @summary update Card
         * @param {string} id Card ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersIdSourcesIdPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CustomersIdSourcesIdPost', 'id', id)
            const localVarPath = `/v1/customers/{id}/sources/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CardApi - functional programming interface
 * @export
 */
export const CardApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CardApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all existing Cards.
         * @summary get all existing Cards
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CustomersIdSourcesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GithubComDriver005GatewayPaymentCardCard>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CustomersIdSourcesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Card by given ID or 404 error.
         * @summary get Card by given ID or 404 error.
         * @param {string} id Card ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CustomersIdSourcesIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GithubComDriver005GatewayPaymentCardCard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CustomersIdSourcesIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update Card.
         * @summary update Card
         * @param {string} id Card ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CustomersIdSourcesIdPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GithubComDriver005GatewayPaymentCardCard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CustomersIdSourcesIdPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CardApi - factory interface
 * @export
 */
export const CardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CardApiFp(configuration)
    return {
        /**
         * Get all existing Cards.
         * @summary get all existing Cards
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersIdSourcesGet(options?: any): AxiosPromise<Array<GithubComDriver005GatewayPaymentCardCard>> {
            return localVarFp.v1CustomersIdSourcesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get Card by given ID or 404 error.
         * @summary get Card by given ID or 404 error.
         * @param {string} id Card ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersIdSourcesIdGet(id: string, options?: any): AxiosPromise<GithubComDriver005GatewayPaymentCardCard> {
            return localVarFp.v1CustomersIdSourcesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Card.
         * @summary update Card
         * @param {string} id Card ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersIdSourcesIdPost(id: string, options?: any): AxiosPromise<GithubComDriver005GatewayPaymentCardCard> {
            return localVarFp.v1CustomersIdSourcesIdPost(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CardApi - object-oriented interface
 * @export
 * @class CardApi
 * @extends {BaseAPI}
 */
export class CardApi extends BaseAPI {
    /**
     * Get all existing Cards.
     * @summary get all existing Cards
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardApi
     */
    public v1CustomersIdSourcesGet(options?: AxiosRequestConfig) {
        return CardApiFp(this.configuration).v1CustomersIdSourcesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Card by given ID or 404 error.
     * @summary get Card by given ID or 404 error.
     * @param {string} id Card ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardApi
     */
    public v1CustomersIdSourcesIdGet(id: string, options?: AxiosRequestConfig) {
        return CardApiFp(this.configuration).v1CustomersIdSourcesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Card.
     * @summary update Card
     * @param {string} id Card ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardApi
     */
    public v1CustomersIdSourcesIdPost(id: string, options?: AxiosRequestConfig) {
        return CardApiFp(this.configuration).v1CustomersIdSourcesIdPost(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CashBalanceApi - axios parameter creator
 * @export
 */
export const CashBalanceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all existing CashBalances.
         * @summary get all existing CashBalances
         * @param {string} id CashBalance ID
         * @param {string} customerId Customer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersIdCashBalanceGet: async (id: string, customerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CustomersIdCashBalanceGet', 'id', id)
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('v1CustomersIdCashBalanceGet', 'customerId', customerId)
            const localVarPath = `/v1/customers/{id}/cash_balance`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete CashBalance by given ID.
         * @summary delete CashBalance by given ID
         * @param {string} id CashBalance ID
         * @param {string} customerId Customer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersIdCashBalanceIdDelete: async (id: string, customerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CustomersIdCashBalanceIdDelete', 'id', id)
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('v1CustomersIdCashBalanceIdDelete', 'customerId', customerId)
            const localVarPath = `/v1/customers/{id}/cash_balance/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CashBalance by given ID or 404 error.
         * @summary get CashBalance by given ID or 404 error.
         * @param {string} id CashBalance ID
         * @param {string} customerId Customer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersIdCashBalanceIdGet: async (id: string, customerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CustomersIdCashBalanceIdGet', 'id', id)
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('v1CustomersIdCashBalanceIdGet', 'customerId', customerId)
            const localVarPath = `/v1/customers/{id}/cash_balance/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update CashBalance.
         * @summary update CashBalance
         * @param {string} id CashBalance ID
         * @param {string} customerId Customer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersIdCashBalanceIdPost: async (id: string, customerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CustomersIdCashBalanceIdPost', 'id', id)
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('v1CustomersIdCashBalanceIdPost', 'customerId', customerId)
            const localVarPath = `/v1/customers/{id}/cash_balance/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"customer_id"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new CashBalance.
         * @summary create a new CashBalance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersIdCashBalancePost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/customers/{id}/cash_balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CashBalanceApi - functional programming interface
 * @export
 */
export const CashBalanceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CashBalanceApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all existing CashBalances.
         * @summary get all existing CashBalances
         * @param {string} id CashBalance ID
         * @param {string} customerId Customer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CustomersIdCashBalanceGet(id: string, customerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CashCashBalance>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CustomersIdCashBalanceGet(id, customerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete CashBalance by given ID.
         * @summary delete CashBalance by given ID
         * @param {string} id CashBalance ID
         * @param {string} customerId Customer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CustomersIdCashBalanceIdDelete(id: string, customerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CustomersIdCashBalanceIdDelete(id, customerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get CashBalance by given ID or 404 error.
         * @summary get CashBalance by given ID or 404 error.
         * @param {string} id CashBalance ID
         * @param {string} customerId Customer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CustomersIdCashBalanceIdGet(id: string, customerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CashCashBalance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CustomersIdCashBalanceIdGet(id, customerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update CashBalance.
         * @summary update CashBalance
         * @param {string} id CashBalance ID
         * @param {string} customerId Customer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CustomersIdCashBalanceIdPost(id: string, customerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CashCashBalance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CustomersIdCashBalanceIdPost(id, customerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new CashBalance.
         * @summary create a new CashBalance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CustomersIdCashBalancePost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CashCashBalance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CustomersIdCashBalancePost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CashBalanceApi - factory interface
 * @export
 */
export const CashBalanceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CashBalanceApiFp(configuration)
    return {
        /**
         * Get all existing CashBalances.
         * @summary get all existing CashBalances
         * @param {string} id CashBalance ID
         * @param {string} customerId Customer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersIdCashBalanceGet(id: string, customerId: string, options?: any): AxiosPromise<Array<CashCashBalance>> {
            return localVarFp.v1CustomersIdCashBalanceGet(id, customerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete CashBalance by given ID.
         * @summary delete CashBalance by given ID
         * @param {string} id CashBalance ID
         * @param {string} customerId Customer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersIdCashBalanceIdDelete(id: string, customerId: string, options?: any): AxiosPromise<string> {
            return localVarFp.v1CustomersIdCashBalanceIdDelete(id, customerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get CashBalance by given ID or 404 error.
         * @summary get CashBalance by given ID or 404 error.
         * @param {string} id CashBalance ID
         * @param {string} customerId Customer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersIdCashBalanceIdGet(id: string, customerId: string, options?: any): AxiosPromise<CashCashBalance> {
            return localVarFp.v1CustomersIdCashBalanceIdGet(id, customerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update CashBalance.
         * @summary update CashBalance
         * @param {string} id CashBalance ID
         * @param {string} customerId Customer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersIdCashBalanceIdPost(id: string, customerId: string, options?: any): AxiosPromise<CashCashBalance> {
            return localVarFp.v1CustomersIdCashBalanceIdPost(id, customerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new CashBalance.
         * @summary create a new CashBalance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersIdCashBalancePost(options?: any): AxiosPromise<CashCashBalance> {
            return localVarFp.v1CustomersIdCashBalancePost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CashBalanceApi - object-oriented interface
 * @export
 * @class CashBalanceApi
 * @extends {BaseAPI}
 */
export class CashBalanceApi extends BaseAPI {
    /**
     * Get all existing CashBalances.
     * @summary get all existing CashBalances
     * @param {string} id CashBalance ID
     * @param {string} customerId Customer ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CashBalanceApi
     */
    public v1CustomersIdCashBalanceGet(id: string, customerId: string, options?: AxiosRequestConfig) {
        return CashBalanceApiFp(this.configuration).v1CustomersIdCashBalanceGet(id, customerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete CashBalance by given ID.
     * @summary delete CashBalance by given ID
     * @param {string} id CashBalance ID
     * @param {string} customerId Customer ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CashBalanceApi
     */
    public v1CustomersIdCashBalanceIdDelete(id: string, customerId: string, options?: AxiosRequestConfig) {
        return CashBalanceApiFp(this.configuration).v1CustomersIdCashBalanceIdDelete(id, customerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get CashBalance by given ID or 404 error.
     * @summary get CashBalance by given ID or 404 error.
     * @param {string} id CashBalance ID
     * @param {string} customerId Customer ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CashBalanceApi
     */
    public v1CustomersIdCashBalanceIdGet(id: string, customerId: string, options?: AxiosRequestConfig) {
        return CashBalanceApiFp(this.configuration).v1CustomersIdCashBalanceIdGet(id, customerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update CashBalance.
     * @summary update CashBalance
     * @param {string} id CashBalance ID
     * @param {string} customerId Customer ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CashBalanceApi
     */
    public v1CustomersIdCashBalanceIdPost(id: string, customerId: string, options?: AxiosRequestConfig) {
        return CashBalanceApiFp(this.configuration).v1CustomersIdCashBalanceIdPost(id, customerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new CashBalance.
     * @summary create a new CashBalance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CashBalanceApi
     */
    public v1CustomersIdCashBalancePost(options?: AxiosRequestConfig) {
        return CashBalanceApiFp(this.configuration).v1CustomersIdCashBalancePost(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ChargeApi - axios parameter creator
 * @export
 */
export const ChargeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all existing Charges.
         * @summary get all existing Charges
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChargesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/charges`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Capture Charge.
         * @summary capture Charge
         * @param {string} id Charge ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChargesIdCapturePost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1ChargesIdCapturePost', 'id', id)
            const localVarPath = `/v1/charges/{id}/capture`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Charge by given ID.
         * @summary delete Charge by given ID
         * @param {string} id Charge ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChargesIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1ChargesIdDelete', 'id', id)
            const localVarPath = `/v1/charges/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Charge by given ID or 404 error.
         * @summary get Charge by given ID or 404 error.
         * @param {string} id Charge ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChargesIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1ChargesIdGet', 'id', id)
            const localVarPath = `/v1/charges/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Charge.
         * @summary update Charge
         * @param {string} id Charge ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChargesIdPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1ChargesIdPost', 'id', id)
            const localVarPath = `/v1/charges/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Charge.
         * @summary create a new Charge
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChargesPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/charges`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChargeApi - functional programming interface
 * @export
 */
export const ChargeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChargeApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all existing Charges.
         * @summary get all existing Charges
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ChargesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ChargeCharge>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ChargesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Capture Charge.
         * @summary capture Charge
         * @param {string} id Charge ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ChargesIdCapturePost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChargeCharge>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ChargesIdCapturePost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete Charge by given ID.
         * @summary delete Charge by given ID
         * @param {string} id Charge ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ChargesIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ChargesIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Charge by given ID or 404 error.
         * @summary get Charge by given ID or 404 error.
         * @param {string} id Charge ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ChargesIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChargeCharge>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ChargesIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update Charge.
         * @summary update Charge
         * @param {string} id Charge ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ChargesIdPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChargeCharge>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ChargesIdPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new Charge.
         * @summary create a new Charge
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ChargesPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChargeCharge>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ChargesPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ChargeApi - factory interface
 * @export
 */
export const ChargeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChargeApiFp(configuration)
    return {
        /**
         * Get all existing Charges.
         * @summary get all existing Charges
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChargesGet(options?: any): AxiosPromise<Array<ChargeCharge>> {
            return localVarFp.v1ChargesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Capture Charge.
         * @summary capture Charge
         * @param {string} id Charge ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChargesIdCapturePost(id: string, options?: any): AxiosPromise<ChargeCharge> {
            return localVarFp.v1ChargesIdCapturePost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete Charge by given ID.
         * @summary delete Charge by given ID
         * @param {string} id Charge ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChargesIdDelete(id: string, options?: any): AxiosPromise<string> {
            return localVarFp.v1ChargesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Charge by given ID or 404 error.
         * @summary get Charge by given ID or 404 error.
         * @param {string} id Charge ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChargesIdGet(id: string, options?: any): AxiosPromise<ChargeCharge> {
            return localVarFp.v1ChargesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Charge.
         * @summary update Charge
         * @param {string} id Charge ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChargesIdPost(id: string, options?: any): AxiosPromise<ChargeCharge> {
            return localVarFp.v1ChargesIdPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new Charge.
         * @summary create a new Charge
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ChargesPost(options?: any): AxiosPromise<ChargeCharge> {
            return localVarFp.v1ChargesPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChargeApi - object-oriented interface
 * @export
 * @class ChargeApi
 * @extends {BaseAPI}
 */
export class ChargeApi extends BaseAPI {
    /**
     * Get all existing Charges.
     * @summary get all existing Charges
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChargeApi
     */
    public v1ChargesGet(options?: AxiosRequestConfig) {
        return ChargeApiFp(this.configuration).v1ChargesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Capture Charge.
     * @summary capture Charge
     * @param {string} id Charge ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChargeApi
     */
    public v1ChargesIdCapturePost(id: string, options?: AxiosRequestConfig) {
        return ChargeApiFp(this.configuration).v1ChargesIdCapturePost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete Charge by given ID.
     * @summary delete Charge by given ID
     * @param {string} id Charge ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChargeApi
     */
    public v1ChargesIdDelete(id: string, options?: AxiosRequestConfig) {
        return ChargeApiFp(this.configuration).v1ChargesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Charge by given ID or 404 error.
     * @summary get Charge by given ID or 404 error.
     * @param {string} id Charge ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChargeApi
     */
    public v1ChargesIdGet(id: string, options?: AxiosRequestConfig) {
        return ChargeApiFp(this.configuration).v1ChargesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Charge.
     * @summary update Charge
     * @param {string} id Charge ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChargeApi
     */
    public v1ChargesIdPost(id: string, options?: AxiosRequestConfig) {
        return ChargeApiFp(this.configuration).v1ChargesIdPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new Charge.
     * @summary create a new Charge
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChargeApi
     */
    public v1ChargesPost(options?: AxiosRequestConfig) {
        return ChargeApiFp(this.configuration).v1ChargesPost(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CheckoutSessionApi - axios parameter creator
 * @export
 */
export const CheckoutSessionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all existing CheckoutSessions.
         * @summary get all existing CheckoutSessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CheckoutSessionsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/checkout/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete CheckoutSession by given ID.
         * @summary delete CheckoutSession by given ID
         * @param {string} id CheckoutSession ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CheckoutSessionsIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CheckoutSessionsIdDelete', 'id', id)
            const localVarPath = `/v1/checkout/sessions/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Expire CheckoutSession.
         * @summary expire CheckoutSession
         * @param {string} id CheckoutSession ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CheckoutSessionsIdExpirePost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CheckoutSessionsIdExpirePost', 'id', id)
            const localVarPath = `/v1/checkout/sessions/{id}/expire`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CheckoutSession by given ID or 404 error.
         * @summary get CheckoutSession by given ID or 404 error.
         * @param {string} id CheckoutSession ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CheckoutSessionsIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CheckoutSessionsIdGet', 'id', id)
            const localVarPath = `/v1/checkout/sessions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update CheckoutSession.
         * @summary update CheckoutSession
         * @param {string} id CheckoutSession ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CheckoutSessionsIdPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CheckoutSessionsIdPost', 'id', id)
            const localVarPath = `/v1/checkout/sessions/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new CheckoutSession.
         * @summary create a new CheckoutSession
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CheckoutSessionsPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/checkout/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CheckoutSessionApi - functional programming interface
 * @export
 */
export const CheckoutSessionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CheckoutSessionApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all existing CheckoutSessions.
         * @summary get all existing CheckoutSessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CheckoutSessionsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CheckoutCheckoutSession>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CheckoutSessionsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete CheckoutSession by given ID.
         * @summary delete CheckoutSession by given ID
         * @param {string} id CheckoutSession ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CheckoutSessionsIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CheckoutSessionsIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Expire CheckoutSession.
         * @summary expire CheckoutSession
         * @param {string} id CheckoutSession ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CheckoutSessionsIdExpirePost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckoutCheckoutSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CheckoutSessionsIdExpirePost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get CheckoutSession by given ID or 404 error.
         * @summary get CheckoutSession by given ID or 404 error.
         * @param {string} id CheckoutSession ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CheckoutSessionsIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckoutCheckoutSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CheckoutSessionsIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update CheckoutSession.
         * @summary update CheckoutSession
         * @param {string} id CheckoutSession ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CheckoutSessionsIdPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckoutCheckoutSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CheckoutSessionsIdPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new CheckoutSession.
         * @summary create a new CheckoutSession
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CheckoutSessionsPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckoutCheckoutSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CheckoutSessionsPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CheckoutSessionApi - factory interface
 * @export
 */
export const CheckoutSessionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CheckoutSessionApiFp(configuration)
    return {
        /**
         * Get all existing CheckoutSessions.
         * @summary get all existing CheckoutSessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CheckoutSessionsGet(options?: any): AxiosPromise<Array<CheckoutCheckoutSession>> {
            return localVarFp.v1CheckoutSessionsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete CheckoutSession by given ID.
         * @summary delete CheckoutSession by given ID
         * @param {string} id CheckoutSession ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CheckoutSessionsIdDelete(id: string, options?: any): AxiosPromise<string> {
            return localVarFp.v1CheckoutSessionsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Expire CheckoutSession.
         * @summary expire CheckoutSession
         * @param {string} id CheckoutSession ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CheckoutSessionsIdExpirePost(id: string, options?: any): AxiosPromise<CheckoutCheckoutSession> {
            return localVarFp.v1CheckoutSessionsIdExpirePost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get CheckoutSession by given ID or 404 error.
         * @summary get CheckoutSession by given ID or 404 error.
         * @param {string} id CheckoutSession ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CheckoutSessionsIdGet(id: string, options?: any): AxiosPromise<CheckoutCheckoutSession> {
            return localVarFp.v1CheckoutSessionsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update CheckoutSession.
         * @summary update CheckoutSession
         * @param {string} id CheckoutSession ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CheckoutSessionsIdPost(id: string, options?: any): AxiosPromise<CheckoutCheckoutSession> {
            return localVarFp.v1CheckoutSessionsIdPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new CheckoutSession.
         * @summary create a new CheckoutSession
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CheckoutSessionsPost(options?: any): AxiosPromise<CheckoutCheckoutSession> {
            return localVarFp.v1CheckoutSessionsPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CheckoutSessionApi - object-oriented interface
 * @export
 * @class CheckoutSessionApi
 * @extends {BaseAPI}
 */
export class CheckoutSessionApi extends BaseAPI {
    /**
     * Get all existing CheckoutSessions.
     * @summary get all existing CheckoutSessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutSessionApi
     */
    public v1CheckoutSessionsGet(options?: AxiosRequestConfig) {
        return CheckoutSessionApiFp(this.configuration).v1CheckoutSessionsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete CheckoutSession by given ID.
     * @summary delete CheckoutSession by given ID
     * @param {string} id CheckoutSession ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutSessionApi
     */
    public v1CheckoutSessionsIdDelete(id: string, options?: AxiosRequestConfig) {
        return CheckoutSessionApiFp(this.configuration).v1CheckoutSessionsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Expire CheckoutSession.
     * @summary expire CheckoutSession
     * @param {string} id CheckoutSession ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutSessionApi
     */
    public v1CheckoutSessionsIdExpirePost(id: string, options?: AxiosRequestConfig) {
        return CheckoutSessionApiFp(this.configuration).v1CheckoutSessionsIdExpirePost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get CheckoutSession by given ID or 404 error.
     * @summary get CheckoutSession by given ID or 404 error.
     * @param {string} id CheckoutSession ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutSessionApi
     */
    public v1CheckoutSessionsIdGet(id: string, options?: AxiosRequestConfig) {
        return CheckoutSessionApiFp(this.configuration).v1CheckoutSessionsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update CheckoutSession.
     * @summary update CheckoutSession
     * @param {string} id CheckoutSession ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutSessionApi
     */
    public v1CheckoutSessionsIdPost(id: string, options?: AxiosRequestConfig) {
        return CheckoutSessionApiFp(this.configuration).v1CheckoutSessionsIdPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new CheckoutSession.
     * @summary create a new CheckoutSession
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutSessionApi
     */
    public v1CheckoutSessionsPost(options?: AxiosRequestConfig) {
        return CheckoutSessionApiFp(this.configuration).v1CheckoutSessionsPost(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CouponApi - axios parameter creator
 * @export
 */
export const CouponApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all existing Coupons.
         * @summary get all existing Coupons
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CouponsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/coupons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Coupon by given ID.
         * @summary delete Coupon by given ID
         * @param {string} id Coupon ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CouponsIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CouponsIdDelete', 'id', id)
            const localVarPath = `/v1/coupons/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Coupon by given ID or 404 error.
         * @summary get Coupon by given ID or 404 error.
         * @param {string} id Coupon ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CouponsIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CouponsIdGet', 'id', id)
            const localVarPath = `/v1/coupons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Coupon.
         * @summary update Coupon
         * @param {string} id Coupon ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CouponsIdPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CouponsIdPost', 'id', id)
            const localVarPath = `/v1/coupons/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Coupon.
         * @summary create a new Coupon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CouponsPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/coupons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CouponApi - functional programming interface
 * @export
 */
export const CouponApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CouponApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all existing Coupons.
         * @summary get all existing Coupons
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CouponsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CouponCoupon>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CouponsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete Coupon by given ID.
         * @summary delete Coupon by given ID
         * @param {string} id Coupon ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CouponsIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CouponsIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Coupon by given ID or 404 error.
         * @summary get Coupon by given ID or 404 error.
         * @param {string} id Coupon ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CouponsIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CouponCoupon>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CouponsIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update Coupon.
         * @summary update Coupon
         * @param {string} id Coupon ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CouponsIdPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CouponCoupon>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CouponsIdPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new Coupon.
         * @summary create a new Coupon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CouponsPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CouponCoupon>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CouponsPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CouponApi - factory interface
 * @export
 */
export const CouponApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CouponApiFp(configuration)
    return {
        /**
         * Get all existing Coupons.
         * @summary get all existing Coupons
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CouponsGet(options?: any): AxiosPromise<Array<CouponCoupon>> {
            return localVarFp.v1CouponsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete Coupon by given ID.
         * @summary delete Coupon by given ID
         * @param {string} id Coupon ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CouponsIdDelete(id: string, options?: any): AxiosPromise<string> {
            return localVarFp.v1CouponsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Coupon by given ID or 404 error.
         * @summary get Coupon by given ID or 404 error.
         * @param {string} id Coupon ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CouponsIdGet(id: string, options?: any): AxiosPromise<CouponCoupon> {
            return localVarFp.v1CouponsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Coupon.
         * @summary update Coupon
         * @param {string} id Coupon ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CouponsIdPost(id: string, options?: any): AxiosPromise<CouponCoupon> {
            return localVarFp.v1CouponsIdPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new Coupon.
         * @summary create a new Coupon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CouponsPost(options?: any): AxiosPromise<CouponCoupon> {
            return localVarFp.v1CouponsPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CouponApi - object-oriented interface
 * @export
 * @class CouponApi
 * @extends {BaseAPI}
 */
export class CouponApi extends BaseAPI {
    /**
     * Get all existing Coupons.
     * @summary get all existing Coupons
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApi
     */
    public v1CouponsGet(options?: AxiosRequestConfig) {
        return CouponApiFp(this.configuration).v1CouponsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete Coupon by given ID.
     * @summary delete Coupon by given ID
     * @param {string} id Coupon ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApi
     */
    public v1CouponsIdDelete(id: string, options?: AxiosRequestConfig) {
        return CouponApiFp(this.configuration).v1CouponsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Coupon by given ID or 404 error.
     * @summary get Coupon by given ID or 404 error.
     * @param {string} id Coupon ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApi
     */
    public v1CouponsIdGet(id: string, options?: AxiosRequestConfig) {
        return CouponApiFp(this.configuration).v1CouponsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Coupon.
     * @summary update Coupon
     * @param {string} id Coupon ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApi
     */
    public v1CouponsIdPost(id: string, options?: AxiosRequestConfig) {
        return CouponApiFp(this.configuration).v1CouponsIdPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new Coupon.
     * @summary create a new Coupon
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApi
     */
    public v1CouponsPost(options?: AxiosRequestConfig) {
        return CouponApiFp(this.configuration).v1CouponsPost(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CreditNoteApi - axios parameter creator
 * @export
 */
export const CreditNoteApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get CreditNote by given ID and return his Linitems.
         * @summary get CreditNote by given ID and return his Linitems.
         * @param {string} id CreditNote ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreditNotesIdLinesGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CreditNotesIdLinesGet', 'id', id)
            const localVarPath = `/v1/credit_notes/{id}/lines`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update CreditNote to status void.
         * @summary update CreditNote to status void
         * @param {string} id CreditNote ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreditNotesIdVoidGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CreditNotesIdVoidGet', 'id', id)
            const localVarPath = `/v1/credit_notes/{id}/void`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CreditNoteApi - functional programming interface
 * @export
 */
export const CreditNoteApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CreditNoteApiAxiosParamCreator(configuration)
    return {
        /**
         * Get CreditNote by given ID and return his Linitems.
         * @summary get CreditNote by given ID and return his Linitems.
         * @param {string} id CreditNote ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CreditNotesIdLinesGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditCreditNote>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CreditNotesIdLinesGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update CreditNote to status void.
         * @summary update CreditNote to status void
         * @param {string} id CreditNote ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CreditNotesIdVoidGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditCreditNote>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CreditNotesIdVoidGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CreditNoteApi - factory interface
 * @export
 */
export const CreditNoteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CreditNoteApiFp(configuration)
    return {
        /**
         * Get CreditNote by given ID and return his Linitems.
         * @summary get CreditNote by given ID and return his Linitems.
         * @param {string} id CreditNote ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreditNotesIdLinesGet(id: string, options?: any): AxiosPromise<CreditCreditNote> {
            return localVarFp.v1CreditNotesIdLinesGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update CreditNote to status void.
         * @summary update CreditNote to status void
         * @param {string} id CreditNote ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreditNotesIdVoidGet(id: string, options?: any): AxiosPromise<CreditCreditNote> {
            return localVarFp.v1CreditNotesIdVoidGet(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CreditNoteApi - object-oriented interface
 * @export
 * @class CreditNoteApi
 * @extends {BaseAPI}
 */
export class CreditNoteApi extends BaseAPI {
    /**
     * Get CreditNote by given ID and return his Linitems.
     * @summary get CreditNote by given ID and return his Linitems.
     * @param {string} id CreditNote ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditNoteApi
     */
    public v1CreditNotesIdLinesGet(id: string, options?: AxiosRequestConfig) {
        return CreditNoteApiFp(this.configuration).v1CreditNotesIdLinesGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update CreditNote to status void.
     * @summary update CreditNote to status void
     * @param {string} id CreditNote ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditNoteApi
     */
    public v1CreditNotesIdVoidGet(id: string, options?: AxiosRequestConfig) {
        return CreditNoteApiFp(this.configuration).v1CreditNotesIdVoidGet(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CustomerApi - axios parameter creator
 * @export
 */
export const CustomerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all existing Customers.
         * @summary get all existing Customers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Customer by given ID.
         * @summary delete Customer by given ID
         * @param {string} id Customer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CustomersIdDelete', 'id', id)
            const localVarPath = `/v1/customers/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Customer by given ID or 404 error.
         * @summary get Customer by given ID or 404 error.
         * @param {string} id Customer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CustomersIdGet', 'id', id)
            const localVarPath = `/v1/customers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Customer.
         * @summary update Customer
         * @param {string} id Customer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersIdPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CustomersIdPost', 'id', id)
            const localVarPath = `/v1/customers/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all existing Customers.
         * @summary get all existing Customers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersIdTaxIdsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/customers/{id}/tax_ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Customer.
         * @summary create a new Customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersIdTaxIdsPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/customers/{id}/tax_ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Customer by given ID.
         * @summary delete Customer by given ID
         * @param {string} taxId Tax ID
         * @param {string} id Customer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersIdTaxIdsTaxIdDelete: async (taxId: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taxId' is not null or undefined
            assertParamExists('v1CustomersIdTaxIdsTaxIdDelete', 'taxId', taxId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CustomersIdTaxIdsTaxIdDelete', 'id', id)
            const localVarPath = `/v1/customers/{id}/tax_ids/{tax_id}`
                .replace(`{${"tax_id"}}`, encodeURIComponent(String(taxId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Customer by given ID or 404 error.
         * @summary get Customer by given ID or 404 error.
         * @param {string} id Customer ID
         * @param {string} taxId Tax ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersIdTaxIdsTaxIdGet: async (id: string, taxId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CustomersIdTaxIdsTaxIdGet', 'id', id)
            // verify required parameter 'taxId' is not null or undefined
            assertParamExists('v1CustomersIdTaxIdsTaxIdGet', 'taxId', taxId)
            const localVarPath = `/v1/customers/{id}/tax_ids/{tax_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"tax_id"}}`, encodeURIComponent(String(taxId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Customer.
         * @summary create a new Customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomerApi - functional programming interface
 * @export
 */
export const CustomerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomerApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all existing Customers.
         * @summary get all existing Customers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CustomersGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomerCustomer>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CustomersGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete Customer by given ID.
         * @summary delete Customer by given ID
         * @param {string} id Customer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CustomersIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CustomersIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Customer by given ID or 404 error.
         * @summary get Customer by given ID or 404 error.
         * @param {string} id Customer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CustomersIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerCustomer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CustomersIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update Customer.
         * @summary update Customer
         * @param {string} id Customer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CustomersIdPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerCustomer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CustomersIdPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all existing Customers.
         * @summary get all existing Customers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CustomersIdTaxIdsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomerCustomer>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CustomersIdTaxIdsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new Customer.
         * @summary create a new Customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CustomersIdTaxIdsPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerCustomer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CustomersIdTaxIdsPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete Customer by given ID.
         * @summary delete Customer by given ID
         * @param {string} taxId Tax ID
         * @param {string} id Customer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CustomersIdTaxIdsTaxIdDelete(taxId: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CustomersIdTaxIdsTaxIdDelete(taxId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Customer by given ID or 404 error.
         * @summary get Customer by given ID or 404 error.
         * @param {string} id Customer ID
         * @param {string} taxId Tax ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CustomersIdTaxIdsTaxIdGet(id: string, taxId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerCustomer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CustomersIdTaxIdsTaxIdGet(id, taxId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new Customer.
         * @summary create a new Customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CustomersPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerCustomer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CustomersPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CustomerApi - factory interface
 * @export
 */
export const CustomerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomerApiFp(configuration)
    return {
        /**
         * Get all existing Customers.
         * @summary get all existing Customers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersGet(options?: any): AxiosPromise<Array<CustomerCustomer>> {
            return localVarFp.v1CustomersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete Customer by given ID.
         * @summary delete Customer by given ID
         * @param {string} id Customer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersIdDelete(id: string, options?: any): AxiosPromise<string> {
            return localVarFp.v1CustomersIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Customer by given ID or 404 error.
         * @summary get Customer by given ID or 404 error.
         * @param {string} id Customer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersIdGet(id: string, options?: any): AxiosPromise<CustomerCustomer> {
            return localVarFp.v1CustomersIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Customer.
         * @summary update Customer
         * @param {string} id Customer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersIdPost(id: string, options?: any): AxiosPromise<CustomerCustomer> {
            return localVarFp.v1CustomersIdPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all existing Customers.
         * @summary get all existing Customers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersIdTaxIdsGet(options?: any): AxiosPromise<Array<CustomerCustomer>> {
            return localVarFp.v1CustomersIdTaxIdsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new Customer.
         * @summary create a new Customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersIdTaxIdsPost(options?: any): AxiosPromise<CustomerCustomer> {
            return localVarFp.v1CustomersIdTaxIdsPost(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete Customer by given ID.
         * @summary delete Customer by given ID
         * @param {string} taxId Tax ID
         * @param {string} id Customer ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersIdTaxIdsTaxIdDelete(taxId: string, id: string, options?: any): AxiosPromise<string> {
            return localVarFp.v1CustomersIdTaxIdsTaxIdDelete(taxId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Customer by given ID or 404 error.
         * @summary get Customer by given ID or 404 error.
         * @param {string} id Customer ID
         * @param {string} taxId Tax ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersIdTaxIdsTaxIdGet(id: string, taxId: string, options?: any): AxiosPromise<CustomerCustomer> {
            return localVarFp.v1CustomersIdTaxIdsTaxIdGet(id, taxId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new Customer.
         * @summary create a new Customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersPost(options?: any): AxiosPromise<CustomerCustomer> {
            return localVarFp.v1CustomersPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomerApi - object-oriented interface
 * @export
 * @class CustomerApi
 * @extends {BaseAPI}
 */
export class CustomerApi extends BaseAPI {
    /**
     * Get all existing Customers.
     * @summary get all existing Customers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public v1CustomersGet(options?: AxiosRequestConfig) {
        return CustomerApiFp(this.configuration).v1CustomersGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete Customer by given ID.
     * @summary delete Customer by given ID
     * @param {string} id Customer ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public v1CustomersIdDelete(id: string, options?: AxiosRequestConfig) {
        return CustomerApiFp(this.configuration).v1CustomersIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Customer by given ID or 404 error.
     * @summary get Customer by given ID or 404 error.
     * @param {string} id Customer ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public v1CustomersIdGet(id: string, options?: AxiosRequestConfig) {
        return CustomerApiFp(this.configuration).v1CustomersIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Customer.
     * @summary update Customer
     * @param {string} id Customer ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public v1CustomersIdPost(id: string, options?: AxiosRequestConfig) {
        return CustomerApiFp(this.configuration).v1CustomersIdPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all existing Customers.
     * @summary get all existing Customers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public v1CustomersIdTaxIdsGet(options?: AxiosRequestConfig) {
        return CustomerApiFp(this.configuration).v1CustomersIdTaxIdsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new Customer.
     * @summary create a new Customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public v1CustomersIdTaxIdsPost(options?: AxiosRequestConfig) {
        return CustomerApiFp(this.configuration).v1CustomersIdTaxIdsPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete Customer by given ID.
     * @summary delete Customer by given ID
     * @param {string} taxId Tax ID
     * @param {string} id Customer ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public v1CustomersIdTaxIdsTaxIdDelete(taxId: string, id: string, options?: AxiosRequestConfig) {
        return CustomerApiFp(this.configuration).v1CustomersIdTaxIdsTaxIdDelete(taxId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Customer by given ID or 404 error.
     * @summary get Customer by given ID or 404 error.
     * @param {string} id Customer ID
     * @param {string} taxId Tax ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public v1CustomersIdTaxIdsTaxIdGet(id: string, taxId: string, options?: AxiosRequestConfig) {
        return CustomerApiFp(this.configuration).v1CustomersIdTaxIdsTaxIdGet(id, taxId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new Customer.
     * @summary create a new Customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public v1CustomersPost(options?: AxiosRequestConfig) {
        return CustomerApiFp(this.configuration).v1CustomersPost(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DiscountApi - axios parameter creator
 * @export
 */
export const DiscountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all existing Discounts.
         * @summary get all existing Discounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersIdDiscountGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/customers/{id}/discount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Discount by given ID.
         * @summary delete Discount by given ID
         * @param {string} id Discount ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersIdDiscountIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CustomersIdDiscountIdDelete', 'id', id)
            const localVarPath = `/v1/customers/{id}/discount/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Discount by given ID or 404 error.
         * @summary get Discount by given ID or 404 error.
         * @param {string} id Discount ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersIdDiscountIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CustomersIdDiscountIdGet', 'id', id)
            const localVarPath = `/v1/customers/{id}/discount/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Discount.
         * @summary update Discount
         * @param {string} id Discount ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersIdDiscountIdPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CustomersIdDiscountIdPost', 'id', id)
            const localVarPath = `/v1/customers/{id}/discount/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Discount.
         * @summary create a new Discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersIdDiscountPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/customers/{id}/discount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DiscountApi - functional programming interface
 * @export
 */
export const DiscountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DiscountApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all existing Discounts.
         * @summary get all existing Discounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CustomersIdDiscountGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DiscountDiscount>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CustomersIdDiscountGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete Discount by given ID.
         * @summary delete Discount by given ID
         * @param {string} id Discount ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CustomersIdDiscountIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CustomersIdDiscountIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Discount by given ID or 404 error.
         * @summary get Discount by given ID or 404 error.
         * @param {string} id Discount ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CustomersIdDiscountIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiscountDiscount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CustomersIdDiscountIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update Discount.
         * @summary update Discount
         * @param {string} id Discount ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CustomersIdDiscountIdPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiscountDiscount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CustomersIdDiscountIdPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new Discount.
         * @summary create a new Discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CustomersIdDiscountPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiscountDiscount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CustomersIdDiscountPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DiscountApi - factory interface
 * @export
 */
export const DiscountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DiscountApiFp(configuration)
    return {
        /**
         * Get all existing Discounts.
         * @summary get all existing Discounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersIdDiscountGet(options?: any): AxiosPromise<Array<DiscountDiscount>> {
            return localVarFp.v1CustomersIdDiscountGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete Discount by given ID.
         * @summary delete Discount by given ID
         * @param {string} id Discount ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersIdDiscountIdDelete(id: string, options?: any): AxiosPromise<string> {
            return localVarFp.v1CustomersIdDiscountIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Discount by given ID or 404 error.
         * @summary get Discount by given ID or 404 error.
         * @param {string} id Discount ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersIdDiscountIdGet(id: string, options?: any): AxiosPromise<DiscountDiscount> {
            return localVarFp.v1CustomersIdDiscountIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Discount.
         * @summary update Discount
         * @param {string} id Discount ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersIdDiscountIdPost(id: string, options?: any): AxiosPromise<DiscountDiscount> {
            return localVarFp.v1CustomersIdDiscountIdPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new Discount.
         * @summary create a new Discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersIdDiscountPost(options?: any): AxiosPromise<DiscountDiscount> {
            return localVarFp.v1CustomersIdDiscountPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DiscountApi - object-oriented interface
 * @export
 * @class DiscountApi
 * @extends {BaseAPI}
 */
export class DiscountApi extends BaseAPI {
    /**
     * Get all existing Discounts.
     * @summary get all existing Discounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountApi
     */
    public v1CustomersIdDiscountGet(options?: AxiosRequestConfig) {
        return DiscountApiFp(this.configuration).v1CustomersIdDiscountGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete Discount by given ID.
     * @summary delete Discount by given ID
     * @param {string} id Discount ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountApi
     */
    public v1CustomersIdDiscountIdDelete(id: string, options?: AxiosRequestConfig) {
        return DiscountApiFp(this.configuration).v1CustomersIdDiscountIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Discount by given ID or 404 error.
     * @summary get Discount by given ID or 404 error.
     * @param {string} id Discount ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountApi
     */
    public v1CustomersIdDiscountIdGet(id: string, options?: AxiosRequestConfig) {
        return DiscountApiFp(this.configuration).v1CustomersIdDiscountIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Discount.
     * @summary update Discount
     * @param {string} id Discount ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountApi
     */
    public v1CustomersIdDiscountIdPost(id: string, options?: AxiosRequestConfig) {
        return DiscountApiFp(this.configuration).v1CustomersIdDiscountIdPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new Discount.
     * @summary create a new Discount
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountApi
     */
    public v1CustomersIdDiscountPost(options?: AxiosRequestConfig) {
        return DiscountApiFp(this.configuration).v1CustomersIdDiscountPost(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DisputeApi - axios parameter creator
 * @export
 */
export const DisputeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all existing Disputes.
         * @summary get all existing Disputes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DisputesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/disputes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Close Dispute.
         * @summary close Dispute
         * @param {string} id Dispute ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DisputesIdClosePost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1DisputesIdClosePost', 'id', id)
            const localVarPath = `/v1/disputes/{id}/close`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Dispute by given ID.
         * @summary delete Dispute by given ID
         * @param {string} id Dispute ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DisputesIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1DisputesIdDelete', 'id', id)
            const localVarPath = `/v1/disputes/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Dispute by given ID or 404 error.
         * @summary get Dispute by given ID or 404 error.
         * @param {string} id Dispute ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DisputesIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1DisputesIdGet', 'id', id)
            const localVarPath = `/v1/disputes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Dispute.
         * @summary update Dispute
         * @param {string} id Dispute ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DisputesIdPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1DisputesIdPost', 'id', id)
            const localVarPath = `/v1/disputes/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Dispute.
         * @summary create a new Dispute
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DisputesPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/disputes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DisputeApi - functional programming interface
 * @export
 */
export const DisputeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DisputeApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all existing Disputes.
         * @summary get all existing Disputes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1DisputesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DisputeDispute>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1DisputesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Close Dispute.
         * @summary close Dispute
         * @param {string} id Dispute ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1DisputesIdClosePost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DisputeDispute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1DisputesIdClosePost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete Dispute by given ID.
         * @summary delete Dispute by given ID
         * @param {string} id Dispute ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1DisputesIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1DisputesIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Dispute by given ID or 404 error.
         * @summary get Dispute by given ID or 404 error.
         * @param {string} id Dispute ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1DisputesIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DisputeDispute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1DisputesIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update Dispute.
         * @summary update Dispute
         * @param {string} id Dispute ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1DisputesIdPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DisputeDispute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1DisputesIdPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new Dispute.
         * @summary create a new Dispute
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1DisputesPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DisputeDispute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1DisputesPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DisputeApi - factory interface
 * @export
 */
export const DisputeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DisputeApiFp(configuration)
    return {
        /**
         * Get all existing Disputes.
         * @summary get all existing Disputes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DisputesGet(options?: any): AxiosPromise<Array<DisputeDispute>> {
            return localVarFp.v1DisputesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Close Dispute.
         * @summary close Dispute
         * @param {string} id Dispute ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DisputesIdClosePost(id: string, options?: any): AxiosPromise<DisputeDispute> {
            return localVarFp.v1DisputesIdClosePost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete Dispute by given ID.
         * @summary delete Dispute by given ID
         * @param {string} id Dispute ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DisputesIdDelete(id: string, options?: any): AxiosPromise<string> {
            return localVarFp.v1DisputesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Dispute by given ID or 404 error.
         * @summary get Dispute by given ID or 404 error.
         * @param {string} id Dispute ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DisputesIdGet(id: string, options?: any): AxiosPromise<DisputeDispute> {
            return localVarFp.v1DisputesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Dispute.
         * @summary update Dispute
         * @param {string} id Dispute ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DisputesIdPost(id: string, options?: any): AxiosPromise<DisputeDispute> {
            return localVarFp.v1DisputesIdPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new Dispute.
         * @summary create a new Dispute
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DisputesPost(options?: any): AxiosPromise<DisputeDispute> {
            return localVarFp.v1DisputesPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DisputeApi - object-oriented interface
 * @export
 * @class DisputeApi
 * @extends {BaseAPI}
 */
export class DisputeApi extends BaseAPI {
    /**
     * Get all existing Disputes.
     * @summary get all existing Disputes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisputeApi
     */
    public v1DisputesGet(options?: AxiosRequestConfig) {
        return DisputeApiFp(this.configuration).v1DisputesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Close Dispute.
     * @summary close Dispute
     * @param {string} id Dispute ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisputeApi
     */
    public v1DisputesIdClosePost(id: string, options?: AxiosRequestConfig) {
        return DisputeApiFp(this.configuration).v1DisputesIdClosePost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete Dispute by given ID.
     * @summary delete Dispute by given ID
     * @param {string} id Dispute ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisputeApi
     */
    public v1DisputesIdDelete(id: string, options?: AxiosRequestConfig) {
        return DisputeApiFp(this.configuration).v1DisputesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Dispute by given ID or 404 error.
     * @summary get Dispute by given ID or 404 error.
     * @param {string} id Dispute ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisputeApi
     */
    public v1DisputesIdGet(id: string, options?: AxiosRequestConfig) {
        return DisputeApiFp(this.configuration).v1DisputesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Dispute.
     * @summary update Dispute
     * @param {string} id Dispute ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisputeApi
     */
    public v1DisputesIdPost(id: string, options?: AxiosRequestConfig) {
        return DisputeApiFp(this.configuration).v1DisputesIdPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new Dispute.
     * @summary create a new Dispute
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisputeApi
     */
    public v1DisputesPost(options?: AxiosRequestConfig) {
        return DisputeApiFp(this.configuration).v1DisputesPost(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FileApi - axios parameter creator
 * @export
 */
export const FileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all existing Files.
         * @summary get all existing Files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1FilesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete File by given ID.
         * @summary delete File by given ID
         * @param {string} id File ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1FilesIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1FilesIdDelete', 'id', id)
            const localVarPath = `/v1/files/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get File by given ID or 404 error.
         * @summary get File by given ID or 404 error.
         * @param {string} id File ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1FilesIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1FilesIdGet', 'id', id)
            const localVarPath = `/v1/files/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update File.
         * @summary update File
         * @param {string} id File ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1FilesIdPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1FilesIdPost', 'id', id)
            const localVarPath = `/v1/files/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new File.
         * @summary create a new File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1FilesPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FileApi - functional programming interface
 * @export
 */
export const FileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FileApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all existing Files.
         * @summary get all existing Files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1FilesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileFile>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1FilesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete File by given ID.
         * @summary delete File by given ID
         * @param {string} id File ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1FilesIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1FilesIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get File by given ID or 404 error.
         * @summary get File by given ID or 404 error.
         * @param {string} id File ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1FilesIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1FilesIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update File.
         * @summary update File
         * @param {string} id File ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1FilesIdPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1FilesIdPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new File.
         * @summary create a new File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1FilesPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1FilesPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FileApi - factory interface
 * @export
 */
export const FileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FileApiFp(configuration)
    return {
        /**
         * Get all existing Files.
         * @summary get all existing Files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1FilesGet(options?: any): AxiosPromise<Array<FileFile>> {
            return localVarFp.v1FilesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete File by given ID.
         * @summary delete File by given ID
         * @param {string} id File ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1FilesIdDelete(id: string, options?: any): AxiosPromise<string> {
            return localVarFp.v1FilesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get File by given ID or 404 error.
         * @summary get File by given ID or 404 error.
         * @param {string} id File ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1FilesIdGet(id: string, options?: any): AxiosPromise<FileFile> {
            return localVarFp.v1FilesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update File.
         * @summary update File
         * @param {string} id File ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1FilesIdPost(id: string, options?: any): AxiosPromise<FileFile> {
            return localVarFp.v1FilesIdPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new File.
         * @summary create a new File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1FilesPost(options?: any): AxiosPromise<FileFile> {
            return localVarFp.v1FilesPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FileApi - object-oriented interface
 * @export
 * @class FileApi
 * @extends {BaseAPI}
 */
export class FileApi extends BaseAPI {
    /**
     * Get all existing Files.
     * @summary get all existing Files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public v1FilesGet(options?: AxiosRequestConfig) {
        return FileApiFp(this.configuration).v1FilesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete File by given ID.
     * @summary delete File by given ID
     * @param {string} id File ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public v1FilesIdDelete(id: string, options?: AxiosRequestConfig) {
        return FileApiFp(this.configuration).v1FilesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get File by given ID or 404 error.
     * @summary get File by given ID or 404 error.
     * @param {string} id File ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public v1FilesIdGet(id: string, options?: AxiosRequestConfig) {
        return FileApiFp(this.configuration).v1FilesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update File.
     * @summary update File
     * @param {string} id File ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public v1FilesIdPost(id: string, options?: AxiosRequestConfig) {
        return FileApiFp(this.configuration).v1FilesIdPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new File.
     * @summary create a new File
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public v1FilesPost(options?: AxiosRequestConfig) {
        return FileApiFp(this.configuration).v1FilesPost(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InvoiceApi - axios parameter creator
 * @export
 */
export const InvoiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all existing Invoices.
         * @summary get all existing Invoices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1InvoicesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel Invoice.
         * @summary cancel Invoice
         * @param {string} id Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1InvoicesIdCancelPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1InvoicesIdCancelPost', 'id', id)
            const localVarPath = `/v1/invoices/{id}/cancel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Capture Invoice.
         * @summary capture Invoice
         * @param {string} id Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1InvoicesIdCapturePost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1InvoicesIdCapturePost', 'id', id)
            const localVarPath = `/v1/invoices/{id}/capture`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Invoice by given ID.
         * @summary delete Invoice by given ID
         * @param {string} id Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1InvoicesIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1InvoicesIdDelete', 'id', id)
            const localVarPath = `/v1/invoices/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finalize Invoice.
         * @summary finalize Invoice
         * @param {string} id Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1InvoicesIdFinalizePost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1InvoicesIdFinalizePost', 'id', id)
            const localVarPath = `/v1/invoices/{id}/finalize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Invoice by given ID or 404 error.
         * @summary get Invoice by given ID or 404 error.
         * @param {string} id Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1InvoicesIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1InvoicesIdGet', 'id', id)
            const localVarPath = `/v1/invoices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark Invoice as uncollectible.
         * @summary mark Invoice as uncollectible
         * @param {string} id Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1InvoicesIdMarkUncollectiblePost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1InvoicesIdMarkUncollectiblePost', 'id', id)
            const localVarPath = `/v1/invoices/{id}/mark_uncollectible`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Pay Invoice.
         * @summary pay Invoice
         * @param {string} id Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1InvoicesIdPayPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1InvoicesIdPayPost', 'id', id)
            const localVarPath = `/v1/invoices/{id}/pay`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Invoice.
         * @summary update Invoice
         * @param {string} id Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1InvoicesIdPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1InvoicesIdPost', 'id', id)
            const localVarPath = `/v1/invoices/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send Invoice.
         * @summary send Invoice
         * @param {string} id Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1InvoicesIdSendPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1InvoicesIdSendPost', 'id', id)
            const localVarPath = `/v1/invoices/{id}/send`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upcoming Invoice.
         * @summary upcoming Invoice
         * @param {string} id Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1InvoicesIdUpcomingPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1InvoicesIdUpcomingPost', 'id', id)
            const localVarPath = `/v1/invoices/{id}/upcoming`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Void Invoice.
         * @summary void Invoice
         * @param {string} id Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1InvoicesIdVoidPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1InvoicesIdVoidPost', 'id', id)
            const localVarPath = `/v1/invoices/{id}/void`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Invoice.
         * @summary create a new Invoice
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1InvoicesPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvoiceApi - functional programming interface
 * @export
 */
export const InvoiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvoiceApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all existing Invoices.
         * @summary get all existing Invoices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1InvoicesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InvoiceInvoice>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1InvoicesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cancel Invoice.
         * @summary cancel Invoice
         * @param {string} id Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1InvoicesIdCancelPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceInvoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1InvoicesIdCancelPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Capture Invoice.
         * @summary capture Invoice
         * @param {string} id Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1InvoicesIdCapturePost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceInvoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1InvoicesIdCapturePost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete Invoice by given ID.
         * @summary delete Invoice by given ID
         * @param {string} id Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1InvoicesIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1InvoicesIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Finalize Invoice.
         * @summary finalize Invoice
         * @param {string} id Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1InvoicesIdFinalizePost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceInvoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1InvoicesIdFinalizePost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Invoice by given ID or 404 error.
         * @summary get Invoice by given ID or 404 error.
         * @param {string} id Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1InvoicesIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceInvoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1InvoicesIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mark Invoice as uncollectible.
         * @summary mark Invoice as uncollectible
         * @param {string} id Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1InvoicesIdMarkUncollectiblePost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceInvoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1InvoicesIdMarkUncollectiblePost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Pay Invoice.
         * @summary pay Invoice
         * @param {string} id Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1InvoicesIdPayPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceInvoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1InvoicesIdPayPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update Invoice.
         * @summary update Invoice
         * @param {string} id Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1InvoicesIdPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceInvoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1InvoicesIdPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Send Invoice.
         * @summary send Invoice
         * @param {string} id Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1InvoicesIdSendPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceInvoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1InvoicesIdSendPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upcoming Invoice.
         * @summary upcoming Invoice
         * @param {string} id Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1InvoicesIdUpcomingPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceInvoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1InvoicesIdUpcomingPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Void Invoice.
         * @summary void Invoice
         * @param {string} id Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1InvoicesIdVoidPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceInvoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1InvoicesIdVoidPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new Invoice.
         * @summary create a new Invoice
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1InvoicesPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceInvoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1InvoicesPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InvoiceApi - factory interface
 * @export
 */
export const InvoiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvoiceApiFp(configuration)
    return {
        /**
         * Get all existing Invoices.
         * @summary get all existing Invoices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1InvoicesGet(options?: any): AxiosPromise<Array<InvoiceInvoice>> {
            return localVarFp.v1InvoicesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel Invoice.
         * @summary cancel Invoice
         * @param {string} id Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1InvoicesIdCancelPost(id: string, options?: any): AxiosPromise<InvoiceInvoice> {
            return localVarFp.v1InvoicesIdCancelPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Capture Invoice.
         * @summary capture Invoice
         * @param {string} id Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1InvoicesIdCapturePost(id: string, options?: any): AxiosPromise<InvoiceInvoice> {
            return localVarFp.v1InvoicesIdCapturePost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete Invoice by given ID.
         * @summary delete Invoice by given ID
         * @param {string} id Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1InvoicesIdDelete(id: string, options?: any): AxiosPromise<string> {
            return localVarFp.v1InvoicesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Finalize Invoice.
         * @summary finalize Invoice
         * @param {string} id Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1InvoicesIdFinalizePost(id: string, options?: any): AxiosPromise<InvoiceInvoice> {
            return localVarFp.v1InvoicesIdFinalizePost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Invoice by given ID or 404 error.
         * @summary get Invoice by given ID or 404 error.
         * @param {string} id Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1InvoicesIdGet(id: string, options?: any): AxiosPromise<InvoiceInvoice> {
            return localVarFp.v1InvoicesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Mark Invoice as uncollectible.
         * @summary mark Invoice as uncollectible
         * @param {string} id Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1InvoicesIdMarkUncollectiblePost(id: string, options?: any): AxiosPromise<InvoiceInvoice> {
            return localVarFp.v1InvoicesIdMarkUncollectiblePost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Pay Invoice.
         * @summary pay Invoice
         * @param {string} id Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1InvoicesIdPayPost(id: string, options?: any): AxiosPromise<InvoiceInvoice> {
            return localVarFp.v1InvoicesIdPayPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Invoice.
         * @summary update Invoice
         * @param {string} id Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1InvoicesIdPost(id: string, options?: any): AxiosPromise<InvoiceInvoice> {
            return localVarFp.v1InvoicesIdPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Send Invoice.
         * @summary send Invoice
         * @param {string} id Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1InvoicesIdSendPost(id: string, options?: any): AxiosPromise<InvoiceInvoice> {
            return localVarFp.v1InvoicesIdSendPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Upcoming Invoice.
         * @summary upcoming Invoice
         * @param {string} id Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1InvoicesIdUpcomingPost(id: string, options?: any): AxiosPromise<InvoiceInvoice> {
            return localVarFp.v1InvoicesIdUpcomingPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Void Invoice.
         * @summary void Invoice
         * @param {string} id Invoice ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1InvoicesIdVoidPost(id: string, options?: any): AxiosPromise<InvoiceInvoice> {
            return localVarFp.v1InvoicesIdVoidPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new Invoice.
         * @summary create a new Invoice
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1InvoicesPost(options?: any): AxiosPromise<InvoiceInvoice> {
            return localVarFp.v1InvoicesPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvoiceApi - object-oriented interface
 * @export
 * @class InvoiceApi
 * @extends {BaseAPI}
 */
export class InvoiceApi extends BaseAPI {
    /**
     * Get all existing Invoices.
     * @summary get all existing Invoices
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public v1InvoicesGet(options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).v1InvoicesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel Invoice.
     * @summary cancel Invoice
     * @param {string} id Invoice ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public v1InvoicesIdCancelPost(id: string, options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).v1InvoicesIdCancelPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Capture Invoice.
     * @summary capture Invoice
     * @param {string} id Invoice ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public v1InvoicesIdCapturePost(id: string, options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).v1InvoicesIdCapturePost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete Invoice by given ID.
     * @summary delete Invoice by given ID
     * @param {string} id Invoice ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public v1InvoicesIdDelete(id: string, options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).v1InvoicesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Finalize Invoice.
     * @summary finalize Invoice
     * @param {string} id Invoice ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public v1InvoicesIdFinalizePost(id: string, options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).v1InvoicesIdFinalizePost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Invoice by given ID or 404 error.
     * @summary get Invoice by given ID or 404 error.
     * @param {string} id Invoice ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public v1InvoicesIdGet(id: string, options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).v1InvoicesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mark Invoice as uncollectible.
     * @summary mark Invoice as uncollectible
     * @param {string} id Invoice ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public v1InvoicesIdMarkUncollectiblePost(id: string, options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).v1InvoicesIdMarkUncollectiblePost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Pay Invoice.
     * @summary pay Invoice
     * @param {string} id Invoice ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public v1InvoicesIdPayPost(id: string, options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).v1InvoicesIdPayPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Invoice.
     * @summary update Invoice
     * @param {string} id Invoice ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public v1InvoicesIdPost(id: string, options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).v1InvoicesIdPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send Invoice.
     * @summary send Invoice
     * @param {string} id Invoice ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public v1InvoicesIdSendPost(id: string, options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).v1InvoicesIdSendPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upcoming Invoice.
     * @summary upcoming Invoice
     * @param {string} id Invoice ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public v1InvoicesIdUpcomingPost(id: string, options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).v1InvoicesIdUpcomingPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Void Invoice.
     * @summary void Invoice
     * @param {string} id Invoice ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public v1InvoicesIdVoidPost(id: string, options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).v1InvoicesIdVoidPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new Invoice.
     * @summary create a new Invoice
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public v1InvoicesPost(options?: AxiosRequestConfig) {
        return InvoiceApiFp(this.configuration).v1InvoicesPost(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InvoiceitemApi - axios parameter creator
 * @export
 */
export const InvoiceitemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all existing Invoiceitems.
         * @summary get all existing Invoiceitems
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1InvoiceitemsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/invoiceitems`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Invoiceitem by given ID.
         * @summary delete Invoiceitem by given ID
         * @param {string} id Invoiceitem ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1InvoiceitemsIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1InvoiceitemsIdDelete', 'id', id)
            const localVarPath = `/v1/invoiceitems/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Invoiceitem by given ID or 404 error.
         * @summary get Invoiceitem by given ID or 404 error.
         * @param {string} id Invoiceitem ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1InvoiceitemsIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1InvoiceitemsIdGet', 'id', id)
            const localVarPath = `/v1/invoiceitems/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Invoiceitem.
         * @summary update Invoiceitem
         * @param {string} id Invoiceitem ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1InvoiceitemsIdPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1InvoiceitemsIdPost', 'id', id)
            const localVarPath = `/v1/invoiceitems/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Invoiceitem.
         * @summary create a new Invoiceitem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1InvoiceitemsPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/invoiceitems`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvoiceitemApi - functional programming interface
 * @export
 */
export const InvoiceitemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvoiceitemApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all existing Invoiceitems.
         * @summary get all existing Invoiceitems
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1InvoiceitemsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InvoiceItemInvoiceitem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1InvoiceitemsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete Invoiceitem by given ID.
         * @summary delete Invoiceitem by given ID
         * @param {string} id Invoiceitem ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1InvoiceitemsIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1InvoiceitemsIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Invoiceitem by given ID or 404 error.
         * @summary get Invoiceitem by given ID or 404 error.
         * @param {string} id Invoiceitem ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1InvoiceitemsIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceItemInvoiceitem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1InvoiceitemsIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update Invoiceitem.
         * @summary update Invoiceitem
         * @param {string} id Invoiceitem ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1InvoiceitemsIdPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceItemInvoiceitem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1InvoiceitemsIdPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new Invoiceitem.
         * @summary create a new Invoiceitem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1InvoiceitemsPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceItemInvoiceitem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1InvoiceitemsPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InvoiceitemApi - factory interface
 * @export
 */
export const InvoiceitemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvoiceitemApiFp(configuration)
    return {
        /**
         * Get all existing Invoiceitems.
         * @summary get all existing Invoiceitems
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1InvoiceitemsGet(options?: any): AxiosPromise<Array<InvoiceItemInvoiceitem>> {
            return localVarFp.v1InvoiceitemsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete Invoiceitem by given ID.
         * @summary delete Invoiceitem by given ID
         * @param {string} id Invoiceitem ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1InvoiceitemsIdDelete(id: string, options?: any): AxiosPromise<string> {
            return localVarFp.v1InvoiceitemsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Invoiceitem by given ID or 404 error.
         * @summary get Invoiceitem by given ID or 404 error.
         * @param {string} id Invoiceitem ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1InvoiceitemsIdGet(id: string, options?: any): AxiosPromise<InvoiceItemInvoiceitem> {
            return localVarFp.v1InvoiceitemsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Invoiceitem.
         * @summary update Invoiceitem
         * @param {string} id Invoiceitem ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1InvoiceitemsIdPost(id: string, options?: any): AxiosPromise<InvoiceItemInvoiceitem> {
            return localVarFp.v1InvoiceitemsIdPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new Invoiceitem.
         * @summary create a new Invoiceitem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1InvoiceitemsPost(options?: any): AxiosPromise<InvoiceItemInvoiceitem> {
            return localVarFp.v1InvoiceitemsPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvoiceitemApi - object-oriented interface
 * @export
 * @class InvoiceitemApi
 * @extends {BaseAPI}
 */
export class InvoiceitemApi extends BaseAPI {
    /**
     * Get all existing Invoiceitems.
     * @summary get all existing Invoiceitems
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceitemApi
     */
    public v1InvoiceitemsGet(options?: AxiosRequestConfig) {
        return InvoiceitemApiFp(this.configuration).v1InvoiceitemsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete Invoiceitem by given ID.
     * @summary delete Invoiceitem by given ID
     * @param {string} id Invoiceitem ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceitemApi
     */
    public v1InvoiceitemsIdDelete(id: string, options?: AxiosRequestConfig) {
        return InvoiceitemApiFp(this.configuration).v1InvoiceitemsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Invoiceitem by given ID or 404 error.
     * @summary get Invoiceitem by given ID or 404 error.
     * @param {string} id Invoiceitem ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceitemApi
     */
    public v1InvoiceitemsIdGet(id: string, options?: AxiosRequestConfig) {
        return InvoiceitemApiFp(this.configuration).v1InvoiceitemsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Invoiceitem.
     * @summary update Invoiceitem
     * @param {string} id Invoiceitem ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceitemApi
     */
    public v1InvoiceitemsIdPost(id: string, options?: AxiosRequestConfig) {
        return InvoiceitemApiFp(this.configuration).v1InvoiceitemsIdPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new Invoiceitem.
     * @summary create a new Invoiceitem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceitemApi
     */
    public v1InvoiceitemsPost(options?: AxiosRequestConfig) {
        return InvoiceitemApiFp(this.configuration).v1InvoiceitemsPost(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LineItemApi - axios parameter creator
 * @export
 */
export const LineItemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all existing LineItems.
         * @summary get all existing LineItems
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreditNotesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/credit_notes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete LineItem by given ID.
         * @summary delete LineItem by given ID
         * @param {string} id LineItem ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreditNotesIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CreditNotesIdDelete', 'id', id)
            const localVarPath = `/v1/credit_notes/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get LineItem by given ID or 404 error.
         * @summary get LineItem by given ID or 404 error.
         * @param {string} id LineItem ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreditNotesIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CreditNotesIdGet', 'id', id)
            const localVarPath = `/v1/credit_notes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update LineItem.
         * @summary update LineItem
         * @param {string} id LineItem ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreditNotesIdPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CreditNotesIdPost', 'id', id)
            const localVarPath = `/v1/credit_notes/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new LineItem.
         * @summary create a new LineItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreditNotesPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/credit_notes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LineItemApi - functional programming interface
 * @export
 */
export const LineItemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LineItemApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all existing LineItems.
         * @summary get all existing LineItems
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CreditNotesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ItemLineItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CreditNotesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete LineItem by given ID.
         * @summary delete LineItem by given ID
         * @param {string} id LineItem ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CreditNotesIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CreditNotesIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get LineItem by given ID or 404 error.
         * @summary get LineItem by given ID or 404 error.
         * @param {string} id LineItem ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CreditNotesIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemLineItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CreditNotesIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update LineItem.
         * @summary update LineItem
         * @param {string} id LineItem ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CreditNotesIdPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemLineItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CreditNotesIdPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new LineItem.
         * @summary create a new LineItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CreditNotesPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemLineItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CreditNotesPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LineItemApi - factory interface
 * @export
 */
export const LineItemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LineItemApiFp(configuration)
    return {
        /**
         * Get all existing LineItems.
         * @summary get all existing LineItems
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreditNotesGet(options?: any): AxiosPromise<Array<ItemLineItem>> {
            return localVarFp.v1CreditNotesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete LineItem by given ID.
         * @summary delete LineItem by given ID
         * @param {string} id LineItem ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreditNotesIdDelete(id: string, options?: any): AxiosPromise<string> {
            return localVarFp.v1CreditNotesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get LineItem by given ID or 404 error.
         * @summary get LineItem by given ID or 404 error.
         * @param {string} id LineItem ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreditNotesIdGet(id: string, options?: any): AxiosPromise<ItemLineItem> {
            return localVarFp.v1CreditNotesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update LineItem.
         * @summary update LineItem
         * @param {string} id LineItem ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreditNotesIdPost(id: string, options?: any): AxiosPromise<ItemLineItem> {
            return localVarFp.v1CreditNotesIdPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new LineItem.
         * @summary create a new LineItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CreditNotesPost(options?: any): AxiosPromise<ItemLineItem> {
            return localVarFp.v1CreditNotesPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LineItemApi - object-oriented interface
 * @export
 * @class LineItemApi
 * @extends {BaseAPI}
 */
export class LineItemApi extends BaseAPI {
    /**
     * Get all existing LineItems.
     * @summary get all existing LineItems
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LineItemApi
     */
    public v1CreditNotesGet(options?: AxiosRequestConfig) {
        return LineItemApiFp(this.configuration).v1CreditNotesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete LineItem by given ID.
     * @summary delete LineItem by given ID
     * @param {string} id LineItem ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LineItemApi
     */
    public v1CreditNotesIdDelete(id: string, options?: AxiosRequestConfig) {
        return LineItemApiFp(this.configuration).v1CreditNotesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get LineItem by given ID or 404 error.
     * @summary get LineItem by given ID or 404 error.
     * @param {string} id LineItem ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LineItemApi
     */
    public v1CreditNotesIdGet(id: string, options?: AxiosRequestConfig) {
        return LineItemApiFp(this.configuration).v1CreditNotesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update LineItem.
     * @summary update LineItem
     * @param {string} id LineItem ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LineItemApi
     */
    public v1CreditNotesIdPost(id: string, options?: AxiosRequestConfig) {
        return LineItemApiFp(this.configuration).v1CreditNotesIdPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new LineItem.
     * @summary create a new LineItem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LineItemApi
     */
    public v1CreditNotesPost(options?: AxiosRequestConfig) {
        return LineItemApiFp(this.configuration).v1CreditNotesPost(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MandateApi - axios parameter creator
 * @export
 */
export const MandateApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all existing Mandates.
         * @summary get all existing Mandates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1MandatesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/mandates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Mandate by given ID.
         * @summary delete Mandate by given ID
         * @param {string} id Mandate ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1MandatesIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1MandatesIdDelete', 'id', id)
            const localVarPath = `/v1/mandates/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Mandate by given ID or 404 error.
         * @summary get Mandate by given ID or 404 error.
         * @param {string} id Mandate ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1MandatesIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1MandatesIdGet', 'id', id)
            const localVarPath = `/v1/mandates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Mandate.
         * @summary update Mandate
         * @param {string} id Mandate ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1MandatesIdPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1MandatesIdPost', 'id', id)
            const localVarPath = `/v1/mandates/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Mandate.
         * @summary create a new Mandate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1MandatesPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/mandates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MandateApi - functional programming interface
 * @export
 */
export const MandateApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MandateApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all existing Mandates.
         * @summary get all existing Mandates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1MandatesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MandateMandate>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1MandatesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete Mandate by given ID.
         * @summary delete Mandate by given ID
         * @param {string} id Mandate ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1MandatesIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1MandatesIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Mandate by given ID or 404 error.
         * @summary get Mandate by given ID or 404 error.
         * @param {string} id Mandate ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1MandatesIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MandateMandate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1MandatesIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update Mandate.
         * @summary update Mandate
         * @param {string} id Mandate ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1MandatesIdPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MandateMandate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1MandatesIdPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new Mandate.
         * @summary create a new Mandate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1MandatesPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MandateMandate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1MandatesPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MandateApi - factory interface
 * @export
 */
export const MandateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MandateApiFp(configuration)
    return {
        /**
         * Get all existing Mandates.
         * @summary get all existing Mandates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1MandatesGet(options?: any): AxiosPromise<Array<MandateMandate>> {
            return localVarFp.v1MandatesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete Mandate by given ID.
         * @summary delete Mandate by given ID
         * @param {string} id Mandate ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1MandatesIdDelete(id: string, options?: any): AxiosPromise<string> {
            return localVarFp.v1MandatesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Mandate by given ID or 404 error.
         * @summary get Mandate by given ID or 404 error.
         * @param {string} id Mandate ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1MandatesIdGet(id: string, options?: any): AxiosPromise<MandateMandate> {
            return localVarFp.v1MandatesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Mandate.
         * @summary update Mandate
         * @param {string} id Mandate ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1MandatesIdPost(id: string, options?: any): AxiosPromise<MandateMandate> {
            return localVarFp.v1MandatesIdPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new Mandate.
         * @summary create a new Mandate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1MandatesPost(options?: any): AxiosPromise<MandateMandate> {
            return localVarFp.v1MandatesPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MandateApi - object-oriented interface
 * @export
 * @class MandateApi
 * @extends {BaseAPI}
 */
export class MandateApi extends BaseAPI {
    /**
     * Get all existing Mandates.
     * @summary get all existing Mandates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MandateApi
     */
    public v1MandatesGet(options?: AxiosRequestConfig) {
        return MandateApiFp(this.configuration).v1MandatesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete Mandate by given ID.
     * @summary delete Mandate by given ID
     * @param {string} id Mandate ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MandateApi
     */
    public v1MandatesIdDelete(id: string, options?: AxiosRequestConfig) {
        return MandateApiFp(this.configuration).v1MandatesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Mandate by given ID or 404 error.
     * @summary get Mandate by given ID or 404 error.
     * @param {string} id Mandate ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MandateApi
     */
    public v1MandatesIdGet(id: string, options?: AxiosRequestConfig) {
        return MandateApiFp(this.configuration).v1MandatesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Mandate.
     * @summary update Mandate
     * @param {string} id Mandate ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MandateApi
     */
    public v1MandatesIdPost(id: string, options?: AxiosRequestConfig) {
        return MandateApiFp(this.configuration).v1MandatesIdPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new Mandate.
     * @summary create a new Mandate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MandateApi
     */
    public v1MandatesPost(options?: AxiosRequestConfig) {
        return MandateApiFp(this.configuration).v1MandatesPost(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PaymentIntentApi - axios parameter creator
 * @export
 */
export const PaymentIntentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all existing PaymentIntents.
         * @summary get all existing PaymentIntents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentIntentsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/payment_intents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete PaymentIntent by given ID.
         * @summary delete PaymentIntent by given ID
         * @param {string} id PaymentIntent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentIntentsIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1PaymentIntentsIdDelete', 'id', id)
            const localVarPath = `/v1/payment_intents/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get PaymentIntent by given ID or 404 error.
         * @summary get PaymentIntent by given ID or 404 error.
         * @param {string} id PaymentIntent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentIntentsIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1PaymentIntentsIdGet', 'id', id)
            const localVarPath = `/v1/payment_intents/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update PaymentIntent.
         * @summary update PaymentIntent
         * @param {string} id PaymentIntent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentIntentsIdPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1PaymentIntentsIdPost', 'id', id)
            const localVarPath = `/v1/payment_intents/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new PaymentIntent.
         * @summary create a new PaymentIntent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentIntentsPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/payment_intents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentIntentApi - functional programming interface
 * @export
 */
export const PaymentIntentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentIntentApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all existing PaymentIntents.
         * @summary get all existing PaymentIntents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentIntentsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IntentPaymentIntent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentIntentsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete PaymentIntent by given ID.
         * @summary delete PaymentIntent by given ID
         * @param {string} id PaymentIntent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentIntentsIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentIntentsIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get PaymentIntent by given ID or 404 error.
         * @summary get PaymentIntent by given ID or 404 error.
         * @param {string} id PaymentIntent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentIntentsIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntentPaymentIntent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentIntentsIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update PaymentIntent.
         * @summary update PaymentIntent
         * @param {string} id PaymentIntent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentIntentsIdPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntentPaymentIntent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentIntentsIdPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new PaymentIntent.
         * @summary create a new PaymentIntent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentIntentsPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntentPaymentIntent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentIntentsPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PaymentIntentApi - factory interface
 * @export
 */
export const PaymentIntentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentIntentApiFp(configuration)
    return {
        /**
         * Get all existing PaymentIntents.
         * @summary get all existing PaymentIntents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentIntentsGet(options?: any): AxiosPromise<Array<IntentPaymentIntent>> {
            return localVarFp.v1PaymentIntentsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete PaymentIntent by given ID.
         * @summary delete PaymentIntent by given ID
         * @param {string} id PaymentIntent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentIntentsIdDelete(id: string, options?: any): AxiosPromise<string> {
            return localVarFp.v1PaymentIntentsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get PaymentIntent by given ID or 404 error.
         * @summary get PaymentIntent by given ID or 404 error.
         * @param {string} id PaymentIntent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentIntentsIdGet(id: string, options?: any): AxiosPromise<IntentPaymentIntent> {
            return localVarFp.v1PaymentIntentsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update PaymentIntent.
         * @summary update PaymentIntent
         * @param {string} id PaymentIntent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentIntentsIdPost(id: string, options?: any): AxiosPromise<IntentPaymentIntent> {
            return localVarFp.v1PaymentIntentsIdPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new PaymentIntent.
         * @summary create a new PaymentIntent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentIntentsPost(options?: any): AxiosPromise<IntentPaymentIntent> {
            return localVarFp.v1PaymentIntentsPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentIntentApi - object-oriented interface
 * @export
 * @class PaymentIntentApi
 * @extends {BaseAPI}
 */
export class PaymentIntentApi extends BaseAPI {
    /**
     * Get all existing PaymentIntents.
     * @summary get all existing PaymentIntents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentIntentApi
     */
    public v1PaymentIntentsGet(options?: AxiosRequestConfig) {
        return PaymentIntentApiFp(this.configuration).v1PaymentIntentsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete PaymentIntent by given ID.
     * @summary delete PaymentIntent by given ID
     * @param {string} id PaymentIntent ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentIntentApi
     */
    public v1PaymentIntentsIdDelete(id: string, options?: AxiosRequestConfig) {
        return PaymentIntentApiFp(this.configuration).v1PaymentIntentsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get PaymentIntent by given ID or 404 error.
     * @summary get PaymentIntent by given ID or 404 error.
     * @param {string} id PaymentIntent ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentIntentApi
     */
    public v1PaymentIntentsIdGet(id: string, options?: AxiosRequestConfig) {
        return PaymentIntentApiFp(this.configuration).v1PaymentIntentsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update PaymentIntent.
     * @summary update PaymentIntent
     * @param {string} id PaymentIntent ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentIntentApi
     */
    public v1PaymentIntentsIdPost(id: string, options?: AxiosRequestConfig) {
        return PaymentIntentApiFp(this.configuration).v1PaymentIntentsIdPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new PaymentIntent.
     * @summary create a new PaymentIntent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentIntentApi
     */
    public v1PaymentIntentsPost(options?: AxiosRequestConfig) {
        return PaymentIntentApiFp(this.configuration).v1PaymentIntentsPost(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PaymentLinkApi - axios parameter creator
 * @export
 */
export const PaymentLinkApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all existing PaymentLinks.
         * @summary get all existing PaymentLinks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentLinksGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/payment_links`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete PaymentLink by given ID.
         * @summary delete PaymentLink by given ID
         * @param {string} id PaymentLink ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentLinksIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1PaymentLinksIdDelete', 'id', id)
            const localVarPath = `/v1/payment_links/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get PaymentLink by given ID or 404 error.
         * @summary get PaymentLink by given ID or 404 error.
         * @param {string} id PaymentLink ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentLinksIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1PaymentLinksIdGet', 'id', id)
            const localVarPath = `/v1/payment_links/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update PaymentLink.
         * @summary update PaymentLink
         * @param {string} id PaymentLink ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentLinksIdPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1PaymentLinksIdPost', 'id', id)
            const localVarPath = `/v1/payment_links/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new PaymentLink.
         * @summary create a new PaymentLink
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentLinksPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/payment_links`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentLinkApi - functional programming interface
 * @export
 */
export const PaymentLinkApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentLinkApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all existing PaymentLinks.
         * @summary get all existing PaymentLinks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentLinksGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LinkPaymentLink>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentLinksGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete PaymentLink by given ID.
         * @summary delete PaymentLink by given ID
         * @param {string} id PaymentLink ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentLinksIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentLinksIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get PaymentLink by given ID or 404 error.
         * @summary get PaymentLink by given ID or 404 error.
         * @param {string} id PaymentLink ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentLinksIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkPaymentLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentLinksIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update PaymentLink.
         * @summary update PaymentLink
         * @param {string} id PaymentLink ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentLinksIdPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkPaymentLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentLinksIdPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new PaymentLink.
         * @summary create a new PaymentLink
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentLinksPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkPaymentLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentLinksPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PaymentLinkApi - factory interface
 * @export
 */
export const PaymentLinkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentLinkApiFp(configuration)
    return {
        /**
         * Get all existing PaymentLinks.
         * @summary get all existing PaymentLinks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentLinksGet(options?: any): AxiosPromise<Array<LinkPaymentLink>> {
            return localVarFp.v1PaymentLinksGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete PaymentLink by given ID.
         * @summary delete PaymentLink by given ID
         * @param {string} id PaymentLink ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentLinksIdDelete(id: string, options?: any): AxiosPromise<string> {
            return localVarFp.v1PaymentLinksIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get PaymentLink by given ID or 404 error.
         * @summary get PaymentLink by given ID or 404 error.
         * @param {string} id PaymentLink ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentLinksIdGet(id: string, options?: any): AxiosPromise<LinkPaymentLink> {
            return localVarFp.v1PaymentLinksIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update PaymentLink.
         * @summary update PaymentLink
         * @param {string} id PaymentLink ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentLinksIdPost(id: string, options?: any): AxiosPromise<LinkPaymentLink> {
            return localVarFp.v1PaymentLinksIdPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new PaymentLink.
         * @summary create a new PaymentLink
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentLinksPost(options?: any): AxiosPromise<LinkPaymentLink> {
            return localVarFp.v1PaymentLinksPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentLinkApi - object-oriented interface
 * @export
 * @class PaymentLinkApi
 * @extends {BaseAPI}
 */
export class PaymentLinkApi extends BaseAPI {
    /**
     * Get all existing PaymentLinks.
     * @summary get all existing PaymentLinks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentLinkApi
     */
    public v1PaymentLinksGet(options?: AxiosRequestConfig) {
        return PaymentLinkApiFp(this.configuration).v1PaymentLinksGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete PaymentLink by given ID.
     * @summary delete PaymentLink by given ID
     * @param {string} id PaymentLink ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentLinkApi
     */
    public v1PaymentLinksIdDelete(id: string, options?: AxiosRequestConfig) {
        return PaymentLinkApiFp(this.configuration).v1PaymentLinksIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get PaymentLink by given ID or 404 error.
     * @summary get PaymentLink by given ID or 404 error.
     * @param {string} id PaymentLink ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentLinkApi
     */
    public v1PaymentLinksIdGet(id: string, options?: AxiosRequestConfig) {
        return PaymentLinkApiFp(this.configuration).v1PaymentLinksIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update PaymentLink.
     * @summary update PaymentLink
     * @param {string} id PaymentLink ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentLinkApi
     */
    public v1PaymentLinksIdPost(id: string, options?: AxiosRequestConfig) {
        return PaymentLinkApiFp(this.configuration).v1PaymentLinksIdPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new PaymentLink.
     * @summary create a new PaymentLink
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentLinkApi
     */
    public v1PaymentLinksPost(options?: AxiosRequestConfig) {
        return PaymentLinkApiFp(this.configuration).v1PaymentLinksPost(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PaymentMethodApi - axios parameter creator
 * @export
 */
export const PaymentMethodApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all existing PaymentMethods.
         * @summary get all existing PaymentMethods
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentMethodsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/payment_methods`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Attaching PaymentMethod to Customer by given ID.
         * @summary attaching PaymentMethod to Customer by given ID
         * @param {string} id PaymentMethod ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentMethodsIdAttachPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1PaymentMethodsIdAttachPost', 'id', id)
            const localVarPath = `/v1/payment_methods/{id}/attach`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete PaymentMethod by given ID.
         * @summary delete PaymentMethod by given ID
         * @param {string} id PaymentMethod ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentMethodsIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1PaymentMethodsIdDelete', 'id', id)
            const localVarPath = `/v1/payment_methods/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * dettaching PaymentMethod from Customer by given ID.
         * @summary dettaching PaymentMethod from Customer by given ID
         * @param {string} id PaymentMethod ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentMethodsIdDettachPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1PaymentMethodsIdDettachPost', 'id', id)
            const localVarPath = `/v1/payment_methods/{id}/dettach`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get PaymentMethod by given ID or 404 error.
         * @summary get PaymentMethod by given ID or 404 error.
         * @param {string} id PaymentMethod ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentMethodsIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1PaymentMethodsIdGet', 'id', id)
            const localVarPath = `/v1/payment_methods/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update PaymentMethod.
         * @summary update PaymentMethod
         * @param {string} id PaymentMethod ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentMethodsIdPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1PaymentMethodsIdPost', 'id', id)
            const localVarPath = `/v1/payment_methods/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new PaymentMethod.
         * @summary create a new PaymentMethod
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentMethodsPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/payment_methods`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentMethodApi - functional programming interface
 * @export
 */
export const PaymentMethodApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentMethodApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all existing PaymentMethods.
         * @summary get all existing PaymentMethods
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentMethodsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MethodPaymentMethod>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentMethodsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Attaching PaymentMethod to Customer by given ID.
         * @summary attaching PaymentMethod to Customer by given ID
         * @param {string} id PaymentMethod ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentMethodsIdAttachPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentMethodsIdAttachPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete PaymentMethod by given ID.
         * @summary delete PaymentMethod by given ID
         * @param {string} id PaymentMethod ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentMethodsIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentMethodsIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * dettaching PaymentMethod from Customer by given ID.
         * @summary dettaching PaymentMethod from Customer by given ID
         * @param {string} id PaymentMethod ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentMethodsIdDettachPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentMethodsIdDettachPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get PaymentMethod by given ID or 404 error.
         * @summary get PaymentMethod by given ID or 404 error.
         * @param {string} id PaymentMethod ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentMethodsIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MethodPaymentMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentMethodsIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update PaymentMethod.
         * @summary update PaymentMethod
         * @param {string} id PaymentMethod ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentMethodsIdPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MethodPaymentMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentMethodsIdPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new PaymentMethod.
         * @summary create a new PaymentMethod
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PaymentMethodsPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MethodPaymentMethod>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PaymentMethodsPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PaymentMethodApi - factory interface
 * @export
 */
export const PaymentMethodApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentMethodApiFp(configuration)
    return {
        /**
         * Get all existing PaymentMethods.
         * @summary get all existing PaymentMethods
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentMethodsGet(options?: any): AxiosPromise<Array<MethodPaymentMethod>> {
            return localVarFp.v1PaymentMethodsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Attaching PaymentMethod to Customer by given ID.
         * @summary attaching PaymentMethod to Customer by given ID
         * @param {string} id PaymentMethod ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentMethodsIdAttachPost(id: string, options?: any): AxiosPromise<string> {
            return localVarFp.v1PaymentMethodsIdAttachPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete PaymentMethod by given ID.
         * @summary delete PaymentMethod by given ID
         * @param {string} id PaymentMethod ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentMethodsIdDelete(id: string, options?: any): AxiosPromise<string> {
            return localVarFp.v1PaymentMethodsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * dettaching PaymentMethod from Customer by given ID.
         * @summary dettaching PaymentMethod from Customer by given ID
         * @param {string} id PaymentMethod ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentMethodsIdDettachPost(id: string, options?: any): AxiosPromise<string> {
            return localVarFp.v1PaymentMethodsIdDettachPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get PaymentMethod by given ID or 404 error.
         * @summary get PaymentMethod by given ID or 404 error.
         * @param {string} id PaymentMethod ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentMethodsIdGet(id: string, options?: any): AxiosPromise<MethodPaymentMethod> {
            return localVarFp.v1PaymentMethodsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update PaymentMethod.
         * @summary update PaymentMethod
         * @param {string} id PaymentMethod ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentMethodsIdPost(id: string, options?: any): AxiosPromise<MethodPaymentMethod> {
            return localVarFp.v1PaymentMethodsIdPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new PaymentMethod.
         * @summary create a new PaymentMethod
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PaymentMethodsPost(options?: any): AxiosPromise<MethodPaymentMethod> {
            return localVarFp.v1PaymentMethodsPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentMethodApi - object-oriented interface
 * @export
 * @class PaymentMethodApi
 * @extends {BaseAPI}
 */
export class PaymentMethodApi extends BaseAPI {
    /**
     * Get all existing PaymentMethods.
     * @summary get all existing PaymentMethods
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodApi
     */
    public v1PaymentMethodsGet(options?: AxiosRequestConfig) {
        return PaymentMethodApiFp(this.configuration).v1PaymentMethodsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Attaching PaymentMethod to Customer by given ID.
     * @summary attaching PaymentMethod to Customer by given ID
     * @param {string} id PaymentMethod ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodApi
     */
    public v1PaymentMethodsIdAttachPost(id: string, options?: AxiosRequestConfig) {
        return PaymentMethodApiFp(this.configuration).v1PaymentMethodsIdAttachPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete PaymentMethod by given ID.
     * @summary delete PaymentMethod by given ID
     * @param {string} id PaymentMethod ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodApi
     */
    public v1PaymentMethodsIdDelete(id: string, options?: AxiosRequestConfig) {
        return PaymentMethodApiFp(this.configuration).v1PaymentMethodsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * dettaching PaymentMethod from Customer by given ID.
     * @summary dettaching PaymentMethod from Customer by given ID
     * @param {string} id PaymentMethod ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodApi
     */
    public v1PaymentMethodsIdDettachPost(id: string, options?: AxiosRequestConfig) {
        return PaymentMethodApiFp(this.configuration).v1PaymentMethodsIdDettachPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get PaymentMethod by given ID or 404 error.
     * @summary get PaymentMethod by given ID or 404 error.
     * @param {string} id PaymentMethod ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodApi
     */
    public v1PaymentMethodsIdGet(id: string, options?: AxiosRequestConfig) {
        return PaymentMethodApiFp(this.configuration).v1PaymentMethodsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update PaymentMethod.
     * @summary update PaymentMethod
     * @param {string} id PaymentMethod ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodApi
     */
    public v1PaymentMethodsIdPost(id: string, options?: AxiosRequestConfig) {
        return PaymentMethodApiFp(this.configuration).v1PaymentMethodsIdPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new PaymentMethod.
     * @summary create a new PaymentMethod
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodApi
     */
    public v1PaymentMethodsPost(options?: AxiosRequestConfig) {
        return PaymentMethodApiFp(this.configuration).v1PaymentMethodsPost(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PayoutApi - axios parameter creator
 * @export
 */
export const PayoutApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all existing Payouts.
         * @summary get all existing Payouts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PayoutsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/payouts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel Payout.
         * @summary cancel Payout
         * @param {string} id Payout ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PayoutsIdCancelePost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1PayoutsIdCancelePost', 'id', id)
            const localVarPath = `/v1/payouts/{id}/cancele`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Payout by given ID.
         * @summary delete Payout by given ID
         * @param {string} id Payout ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PayoutsIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1PayoutsIdDelete', 'id', id)
            const localVarPath = `/v1/payouts/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Payout by given ID or 404 error.
         * @summary get Payout by given ID or 404 error.
         * @param {string} id Payout ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PayoutsIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1PayoutsIdGet', 'id', id)
            const localVarPath = `/v1/payouts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Payout.
         * @summary update Payout
         * @param {string} id Payout ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PayoutsIdPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1PayoutsIdPost', 'id', id)
            const localVarPath = `/v1/payouts/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reverse Payout.
         * @summary reverse Payout
         * @param {string} id Payout ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PayoutsIdReversePost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1PayoutsIdReversePost', 'id', id)
            const localVarPath = `/v1/payouts/{id}/reverse`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Payout.
         * @summary create a new Payout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PayoutsPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/payouts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PayoutApi - functional programming interface
 * @export
 */
export const PayoutApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PayoutApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all existing Payouts.
         * @summary get all existing Payouts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PayoutsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PayoutPayout>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PayoutsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cancel Payout.
         * @summary cancel Payout
         * @param {string} id Payout ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PayoutsIdCancelePost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayoutPayout>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PayoutsIdCancelePost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete Payout by given ID.
         * @summary delete Payout by given ID
         * @param {string} id Payout ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PayoutsIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PayoutsIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Payout by given ID or 404 error.
         * @summary get Payout by given ID or 404 error.
         * @param {string} id Payout ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PayoutsIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayoutPayout>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PayoutsIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update Payout.
         * @summary update Payout
         * @param {string} id Payout ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PayoutsIdPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayoutPayout>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PayoutsIdPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Reverse Payout.
         * @summary reverse Payout
         * @param {string} id Payout ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PayoutsIdReversePost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayoutPayout>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PayoutsIdReversePost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new Payout.
         * @summary create a new Payout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PayoutsPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayoutPayout>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PayoutsPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PayoutApi - factory interface
 * @export
 */
export const PayoutApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PayoutApiFp(configuration)
    return {
        /**
         * Get all existing Payouts.
         * @summary get all existing Payouts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PayoutsGet(options?: any): AxiosPromise<Array<PayoutPayout>> {
            return localVarFp.v1PayoutsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel Payout.
         * @summary cancel Payout
         * @param {string} id Payout ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PayoutsIdCancelePost(id: string, options?: any): AxiosPromise<PayoutPayout> {
            return localVarFp.v1PayoutsIdCancelePost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete Payout by given ID.
         * @summary delete Payout by given ID
         * @param {string} id Payout ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PayoutsIdDelete(id: string, options?: any): AxiosPromise<string> {
            return localVarFp.v1PayoutsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Payout by given ID or 404 error.
         * @summary get Payout by given ID or 404 error.
         * @param {string} id Payout ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PayoutsIdGet(id: string, options?: any): AxiosPromise<PayoutPayout> {
            return localVarFp.v1PayoutsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Payout.
         * @summary update Payout
         * @param {string} id Payout ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PayoutsIdPost(id: string, options?: any): AxiosPromise<PayoutPayout> {
            return localVarFp.v1PayoutsIdPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Reverse Payout.
         * @summary reverse Payout
         * @param {string} id Payout ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PayoutsIdReversePost(id: string, options?: any): AxiosPromise<PayoutPayout> {
            return localVarFp.v1PayoutsIdReversePost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new Payout.
         * @summary create a new Payout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PayoutsPost(options?: any): AxiosPromise<PayoutPayout> {
            return localVarFp.v1PayoutsPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PayoutApi - object-oriented interface
 * @export
 * @class PayoutApi
 * @extends {BaseAPI}
 */
export class PayoutApi extends BaseAPI {
    /**
     * Get all existing Payouts.
     * @summary get all existing Payouts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutApi
     */
    public v1PayoutsGet(options?: AxiosRequestConfig) {
        return PayoutApiFp(this.configuration).v1PayoutsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel Payout.
     * @summary cancel Payout
     * @param {string} id Payout ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutApi
     */
    public v1PayoutsIdCancelePost(id: string, options?: AxiosRequestConfig) {
        return PayoutApiFp(this.configuration).v1PayoutsIdCancelePost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete Payout by given ID.
     * @summary delete Payout by given ID
     * @param {string} id Payout ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutApi
     */
    public v1PayoutsIdDelete(id: string, options?: AxiosRequestConfig) {
        return PayoutApiFp(this.configuration).v1PayoutsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Payout by given ID or 404 error.
     * @summary get Payout by given ID or 404 error.
     * @param {string} id Payout ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutApi
     */
    public v1PayoutsIdGet(id: string, options?: AxiosRequestConfig) {
        return PayoutApiFp(this.configuration).v1PayoutsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Payout.
     * @summary update Payout
     * @param {string} id Payout ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutApi
     */
    public v1PayoutsIdPost(id: string, options?: AxiosRequestConfig) {
        return PayoutApiFp(this.configuration).v1PayoutsIdPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reverse Payout.
     * @summary reverse Payout
     * @param {string} id Payout ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutApi
     */
    public v1PayoutsIdReversePost(id: string, options?: AxiosRequestConfig) {
        return PayoutApiFp(this.configuration).v1PayoutsIdReversePost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new Payout.
     * @summary create a new Payout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutApi
     */
    public v1PayoutsPost(options?: AxiosRequestConfig) {
        return PayoutApiFp(this.configuration).v1PayoutsPost(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PlanApi - axios parameter creator
 * @export
 */
export const PlanApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all existing Plans.
         * @summary get all existing Plans
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PlansGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/plans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Plan by given ID.
         * @summary delete Plan by given ID
         * @param {string} id Plan ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PlansIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1PlansIdDelete', 'id', id)
            const localVarPath = `/v1/plans/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Plan by given ID or 404 error.
         * @summary get Plan by given ID or 404 error.
         * @param {string} id Plan ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PlansIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1PlansIdGet', 'id', id)
            const localVarPath = `/v1/plans/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Plan.
         * @summary update Plan
         * @param {string} id Plan ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PlansIdPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1PlansIdPost', 'id', id)
            const localVarPath = `/v1/plans/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Plan.
         * @summary create a new Plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PlansPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/plans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlanApi - functional programming interface
 * @export
 */
export const PlanApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlanApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all existing Plans.
         * @summary get all existing Plans
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PlansGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PlanPlan>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PlansGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete Plan by given ID.
         * @summary delete Plan by given ID
         * @param {string} id Plan ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PlansIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PlansIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Plan by given ID or 404 error.
         * @summary get Plan by given ID or 404 error.
         * @param {string} id Plan ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PlansIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlanPlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PlansIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update Plan.
         * @summary update Plan
         * @param {string} id Plan ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PlansIdPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlanPlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PlansIdPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new Plan.
         * @summary create a new Plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PlansPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlanPlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PlansPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PlanApi - factory interface
 * @export
 */
export const PlanApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlanApiFp(configuration)
    return {
        /**
         * Get all existing Plans.
         * @summary get all existing Plans
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PlansGet(options?: any): AxiosPromise<Array<PlanPlan>> {
            return localVarFp.v1PlansGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete Plan by given ID.
         * @summary delete Plan by given ID
         * @param {string} id Plan ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PlansIdDelete(id: string, options?: any): AxiosPromise<string> {
            return localVarFp.v1PlansIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Plan by given ID or 404 error.
         * @summary get Plan by given ID or 404 error.
         * @param {string} id Plan ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PlansIdGet(id: string, options?: any): AxiosPromise<PlanPlan> {
            return localVarFp.v1PlansIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Plan.
         * @summary update Plan
         * @param {string} id Plan ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PlansIdPost(id: string, options?: any): AxiosPromise<PlanPlan> {
            return localVarFp.v1PlansIdPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new Plan.
         * @summary create a new Plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PlansPost(options?: any): AxiosPromise<PlanPlan> {
            return localVarFp.v1PlansPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlanApi - object-oriented interface
 * @export
 * @class PlanApi
 * @extends {BaseAPI}
 */
export class PlanApi extends BaseAPI {
    /**
     * Get all existing Plans.
     * @summary get all existing Plans
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlanApi
     */
    public v1PlansGet(options?: AxiosRequestConfig) {
        return PlanApiFp(this.configuration).v1PlansGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete Plan by given ID.
     * @summary delete Plan by given ID
     * @param {string} id Plan ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlanApi
     */
    public v1PlansIdDelete(id: string, options?: AxiosRequestConfig) {
        return PlanApiFp(this.configuration).v1PlansIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Plan by given ID or 404 error.
     * @summary get Plan by given ID or 404 error.
     * @param {string} id Plan ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlanApi
     */
    public v1PlansIdGet(id: string, options?: AxiosRequestConfig) {
        return PlanApiFp(this.configuration).v1PlansIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Plan.
     * @summary update Plan
     * @param {string} id Plan ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlanApi
     */
    public v1PlansIdPost(id: string, options?: AxiosRequestConfig) {
        return PlanApiFp(this.configuration).v1PlansIdPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new Plan.
     * @summary create a new Plan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlanApi
     */
    public v1PlansPost(options?: AxiosRequestConfig) {
        return PlanApiFp(this.configuration).v1PlansPost(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PriceApi - axios parameter creator
 * @export
 */
export const PriceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all existing Prices.
         * @summary get all existing Prices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PricesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/prices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Price by given ID.
         * @summary delete Price by given ID
         * @param {string} id Price ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PricesIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1PricesIdDelete', 'id', id)
            const localVarPath = `/v1/prices/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Price by given ID or 404 error.
         * @summary get Price by given ID or 404 error.
         * @param {string} id Price ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PricesIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1PricesIdGet', 'id', id)
            const localVarPath = `/v1/prices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Price.
         * @summary update Price
         * @param {string} id Price ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PricesIdPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1PricesIdPost', 'id', id)
            const localVarPath = `/v1/prices/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Price.
         * @summary create a new Price
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PricesPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/prices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PriceApi - functional programming interface
 * @export
 */
export const PriceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PriceApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all existing Prices.
         * @summary get all existing Prices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PricesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PricePrice>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PricesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete Price by given ID.
         * @summary delete Price by given ID
         * @param {string} id Price ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PricesIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PricesIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Price by given ID or 404 error.
         * @summary get Price by given ID or 404 error.
         * @param {string} id Price ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PricesIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricePrice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PricesIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update Price.
         * @summary update Price
         * @param {string} id Price ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PricesIdPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricePrice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PricesIdPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new Price.
         * @summary create a new Price
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PricesPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricePrice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PricesPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PriceApi - factory interface
 * @export
 */
export const PriceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PriceApiFp(configuration)
    return {
        /**
         * Get all existing Prices.
         * @summary get all existing Prices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PricesGet(options?: any): AxiosPromise<Array<PricePrice>> {
            return localVarFp.v1PricesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete Price by given ID.
         * @summary delete Price by given ID
         * @param {string} id Price ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PricesIdDelete(id: string, options?: any): AxiosPromise<string> {
            return localVarFp.v1PricesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Price by given ID or 404 error.
         * @summary get Price by given ID or 404 error.
         * @param {string} id Price ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PricesIdGet(id: string, options?: any): AxiosPromise<PricePrice> {
            return localVarFp.v1PricesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Price.
         * @summary update Price
         * @param {string} id Price ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PricesIdPost(id: string, options?: any): AxiosPromise<PricePrice> {
            return localVarFp.v1PricesIdPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new Price.
         * @summary create a new Price
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PricesPost(options?: any): AxiosPromise<PricePrice> {
            return localVarFp.v1PricesPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PriceApi - object-oriented interface
 * @export
 * @class PriceApi
 * @extends {BaseAPI}
 */
export class PriceApi extends BaseAPI {
    /**
     * Get all existing Prices.
     * @summary get all existing Prices
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PriceApi
     */
    public v1PricesGet(options?: AxiosRequestConfig) {
        return PriceApiFp(this.configuration).v1PricesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete Price by given ID.
     * @summary delete Price by given ID
     * @param {string} id Price ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PriceApi
     */
    public v1PricesIdDelete(id: string, options?: AxiosRequestConfig) {
        return PriceApiFp(this.configuration).v1PricesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Price by given ID or 404 error.
     * @summary get Price by given ID or 404 error.
     * @param {string} id Price ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PriceApi
     */
    public v1PricesIdGet(id: string, options?: AxiosRequestConfig) {
        return PriceApiFp(this.configuration).v1PricesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Price.
     * @summary update Price
     * @param {string} id Price ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PriceApi
     */
    public v1PricesIdPost(id: string, options?: AxiosRequestConfig) {
        return PriceApiFp(this.configuration).v1PricesIdPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new Price.
     * @summary create a new Price
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PriceApi
     */
    public v1PricesPost(options?: AxiosRequestConfig) {
        return PriceApiFp(this.configuration).v1PricesPost(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductApi - axios parameter creator
 * @export
 */
export const ProductApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all existing Products.
         * @summary get all existing Products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProductsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Product by given ID.
         * @summary delete Product by given ID
         * @param {string} id Product ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProductsIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1ProductsIdDelete', 'id', id)
            const localVarPath = `/v1/products/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Product by given ID or 404 error.
         * @summary get Product by given ID or 404 error.
         * @param {string} id Product ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProductsIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1ProductsIdGet', 'id', id)
            const localVarPath = `/v1/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Product.
         * @summary update Product
         * @param {string} id Product ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProductsIdPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1ProductsIdPost', 'id', id)
            const localVarPath = `/v1/products/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Product.
         * @summary create a new Product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProductsPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductApi - functional programming interface
 * @export
 */
export const ProductApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all existing Products.
         * @summary get all existing Products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ProductsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProductProduct>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProductsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete Product by given ID.
         * @summary delete Product by given ID
         * @param {string} id Product ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ProductsIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProductsIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Product by given ID or 404 error.
         * @summary get Product by given ID or 404 error.
         * @param {string} id Product ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ProductsIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductProduct>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProductsIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update Product.
         * @summary update Product
         * @param {string} id Product ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ProductsIdPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductProduct>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProductsIdPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new Product.
         * @summary create a new Product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1ProductsPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductProduct>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProductsPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductApi - factory interface
 * @export
 */
export const ProductApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductApiFp(configuration)
    return {
        /**
         * Get all existing Products.
         * @summary get all existing Products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProductsGet(options?: any): AxiosPromise<Array<ProductProduct>> {
            return localVarFp.v1ProductsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete Product by given ID.
         * @summary delete Product by given ID
         * @param {string} id Product ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProductsIdDelete(id: string, options?: any): AxiosPromise<string> {
            return localVarFp.v1ProductsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Product by given ID or 404 error.
         * @summary get Product by given ID or 404 error.
         * @param {string} id Product ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProductsIdGet(id: string, options?: any): AxiosPromise<ProductProduct> {
            return localVarFp.v1ProductsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Product.
         * @summary update Product
         * @param {string} id Product ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProductsIdPost(id: string, options?: any): AxiosPromise<ProductProduct> {
            return localVarFp.v1ProductsIdPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new Product.
         * @summary create a new Product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ProductsPost(options?: any): AxiosPromise<ProductProduct> {
            return localVarFp.v1ProductsPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductApi - object-oriented interface
 * @export
 * @class ProductApi
 * @extends {BaseAPI}
 */
export class ProductApi extends BaseAPI {
    /**
     * Get all existing Products.
     * @summary get all existing Products
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public v1ProductsGet(options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).v1ProductsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete Product by given ID.
     * @summary delete Product by given ID
     * @param {string} id Product ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public v1ProductsIdDelete(id: string, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).v1ProductsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Product by given ID or 404 error.
     * @summary get Product by given ID or 404 error.
     * @param {string} id Product ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public v1ProductsIdGet(id: string, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).v1ProductsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Product.
     * @summary update Product
     * @param {string} id Product ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public v1ProductsIdPost(id: string, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).v1ProductsIdPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new Product.
     * @summary create a new Product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public v1ProductsPost(options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).v1ProductsPost(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PromotionCodeApi - axios parameter creator
 * @export
 */
export const PromotionCodeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all existing PromotionCodes.
         * @summary get all existing PromotionCodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PromotionCodesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/promotion_codes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete PromotionCode by given ID.
         * @summary delete PromotionCode by given ID
         * @param {string} id PromotionCode ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PromotionCodesIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1PromotionCodesIdDelete', 'id', id)
            const localVarPath = `/v1/promotion_codes/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get PromotionCode by given ID or 404 error.
         * @summary get PromotionCode by given ID or 404 error.
         * @param {string} id PromotionCode ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PromotionCodesIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1PromotionCodesIdGet', 'id', id)
            const localVarPath = `/v1/promotion_codes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update PromotionCode.
         * @summary update PromotionCode
         * @param {string} id PromotionCode ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PromotionCodesIdPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1PromotionCodesIdPost', 'id', id)
            const localVarPath = `/v1/promotion_codes/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new PromotionCode.
         * @summary create a new PromotionCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PromotionCodesPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/promotion_codes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PromotionCodeApi - functional programming interface
 * @export
 */
export const PromotionCodeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PromotionCodeApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all existing PromotionCodes.
         * @summary get all existing PromotionCodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PromotionCodesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PromotionPromotionCode>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PromotionCodesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete PromotionCode by given ID.
         * @summary delete PromotionCode by given ID
         * @param {string} id PromotionCode ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PromotionCodesIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PromotionCodesIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get PromotionCode by given ID or 404 error.
         * @summary get PromotionCode by given ID or 404 error.
         * @param {string} id PromotionCode ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PromotionCodesIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PromotionPromotionCode>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PromotionCodesIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update PromotionCode.
         * @summary update PromotionCode
         * @param {string} id PromotionCode ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PromotionCodesIdPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PromotionPromotionCode>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PromotionCodesIdPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new PromotionCode.
         * @summary create a new PromotionCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1PromotionCodesPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PromotionPromotionCode>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1PromotionCodesPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PromotionCodeApi - factory interface
 * @export
 */
export const PromotionCodeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PromotionCodeApiFp(configuration)
    return {
        /**
         * Get all existing PromotionCodes.
         * @summary get all existing PromotionCodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PromotionCodesGet(options?: any): AxiosPromise<Array<PromotionPromotionCode>> {
            return localVarFp.v1PromotionCodesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete PromotionCode by given ID.
         * @summary delete PromotionCode by given ID
         * @param {string} id PromotionCode ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PromotionCodesIdDelete(id: string, options?: any): AxiosPromise<string> {
            return localVarFp.v1PromotionCodesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get PromotionCode by given ID or 404 error.
         * @summary get PromotionCode by given ID or 404 error.
         * @param {string} id PromotionCode ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PromotionCodesIdGet(id: string, options?: any): AxiosPromise<PromotionPromotionCode> {
            return localVarFp.v1PromotionCodesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update PromotionCode.
         * @summary update PromotionCode
         * @param {string} id PromotionCode ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PromotionCodesIdPost(id: string, options?: any): AxiosPromise<PromotionPromotionCode> {
            return localVarFp.v1PromotionCodesIdPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new PromotionCode.
         * @summary create a new PromotionCode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PromotionCodesPost(options?: any): AxiosPromise<PromotionPromotionCode> {
            return localVarFp.v1PromotionCodesPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PromotionCodeApi - object-oriented interface
 * @export
 * @class PromotionCodeApi
 * @extends {BaseAPI}
 */
export class PromotionCodeApi extends BaseAPI {
    /**
     * Get all existing PromotionCodes.
     * @summary get all existing PromotionCodes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromotionCodeApi
     */
    public v1PromotionCodesGet(options?: AxiosRequestConfig) {
        return PromotionCodeApiFp(this.configuration).v1PromotionCodesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete PromotionCode by given ID.
     * @summary delete PromotionCode by given ID
     * @param {string} id PromotionCode ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromotionCodeApi
     */
    public v1PromotionCodesIdDelete(id: string, options?: AxiosRequestConfig) {
        return PromotionCodeApiFp(this.configuration).v1PromotionCodesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get PromotionCode by given ID or 404 error.
     * @summary get PromotionCode by given ID or 404 error.
     * @param {string} id PromotionCode ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromotionCodeApi
     */
    public v1PromotionCodesIdGet(id: string, options?: AxiosRequestConfig) {
        return PromotionCodeApiFp(this.configuration).v1PromotionCodesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update PromotionCode.
     * @summary update PromotionCode
     * @param {string} id PromotionCode ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromotionCodeApi
     */
    public v1PromotionCodesIdPost(id: string, options?: AxiosRequestConfig) {
        return PromotionCodeApiFp(this.configuration).v1PromotionCodesIdPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new PromotionCode.
     * @summary create a new PromotionCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromotionCodeApi
     */
    public v1PromotionCodesPost(options?: AxiosRequestConfig) {
        return PromotionCodeApiFp(this.configuration).v1PromotionCodesPost(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QuoteApi - axios parameter creator
 * @export
 */
export const QuoteApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all existing Quotes.
         * @summary get all existing Quotes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1QuotesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/quotes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accept Quote.
         * @summary accept Quote
         * @param {string} id Quote ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1QuotesIdAcceptPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1QuotesIdAcceptPost', 'id', id)
            const localVarPath = `/v1/quotes/{id}/accept`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel Quote.
         * @summary cancel Quote
         * @param {string} id Quote ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1QuotesIdCancelPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1QuotesIdCancelPost', 'id', id)
            const localVarPath = `/v1/quotes/{id}/cancel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Quote by given ID.
         * @summary delete Quote by given ID
         * @param {string} id Quote ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1QuotesIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1QuotesIdDelete', 'id', id)
            const localVarPath = `/v1/quotes/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finalize Quote.
         * @summary finalize Quote
         * @param {string} id Quote ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1QuotesIdFinalizePost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1QuotesIdFinalizePost', 'id', id)
            const localVarPath = `/v1/quotes/{id}/finalize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Quote by given ID or 404 error.
         * @summary get Quote by given ID or 404 error.
         * @param {string} id Quote ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1QuotesIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1QuotesIdGet', 'id', id)
            const localVarPath = `/v1/quotes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Quote.
         * @summary update Quote
         * @param {string} id Quote ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1QuotesIdPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1QuotesIdPost', 'id', id)
            const localVarPath = `/v1/quotes/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Quote.
         * @summary create a new Quote
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1QuotesPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/quotes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuoteApi - functional programming interface
 * @export
 */
export const QuoteApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QuoteApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all existing Quotes.
         * @summary get all existing Quotes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1QuotesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<QuoteQuote>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1QuotesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Accept Quote.
         * @summary accept Quote
         * @param {string} id Quote ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1QuotesIdAcceptPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuoteQuote>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1QuotesIdAcceptPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cancel Quote.
         * @summary cancel Quote
         * @param {string} id Quote ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1QuotesIdCancelPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuoteQuote>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1QuotesIdCancelPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete Quote by given ID.
         * @summary delete Quote by given ID
         * @param {string} id Quote ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1QuotesIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1QuotesIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Finalize Quote.
         * @summary finalize Quote
         * @param {string} id Quote ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1QuotesIdFinalizePost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuoteQuote>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1QuotesIdFinalizePost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Quote by given ID or 404 error.
         * @summary get Quote by given ID or 404 error.
         * @param {string} id Quote ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1QuotesIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuoteQuote>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1QuotesIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update Quote.
         * @summary update Quote
         * @param {string} id Quote ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1QuotesIdPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuoteQuote>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1QuotesIdPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new Quote.
         * @summary create a new Quote
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1QuotesPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuoteQuote>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1QuotesPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QuoteApi - factory interface
 * @export
 */
export const QuoteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QuoteApiFp(configuration)
    return {
        /**
         * Get all existing Quotes.
         * @summary get all existing Quotes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1QuotesGet(options?: any): AxiosPromise<Array<QuoteQuote>> {
            return localVarFp.v1QuotesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Accept Quote.
         * @summary accept Quote
         * @param {string} id Quote ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1QuotesIdAcceptPost(id: string, options?: any): AxiosPromise<QuoteQuote> {
            return localVarFp.v1QuotesIdAcceptPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel Quote.
         * @summary cancel Quote
         * @param {string} id Quote ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1QuotesIdCancelPost(id: string, options?: any): AxiosPromise<QuoteQuote> {
            return localVarFp.v1QuotesIdCancelPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete Quote by given ID.
         * @summary delete Quote by given ID
         * @param {string} id Quote ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1QuotesIdDelete(id: string, options?: any): AxiosPromise<string> {
            return localVarFp.v1QuotesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Finalize Quote.
         * @summary finalize Quote
         * @param {string} id Quote ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1QuotesIdFinalizePost(id: string, options?: any): AxiosPromise<QuoteQuote> {
            return localVarFp.v1QuotesIdFinalizePost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Quote by given ID or 404 error.
         * @summary get Quote by given ID or 404 error.
         * @param {string} id Quote ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1QuotesIdGet(id: string, options?: any): AxiosPromise<QuoteQuote> {
            return localVarFp.v1QuotesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Quote.
         * @summary update Quote
         * @param {string} id Quote ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1QuotesIdPost(id: string, options?: any): AxiosPromise<QuoteQuote> {
            return localVarFp.v1QuotesIdPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new Quote.
         * @summary create a new Quote
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1QuotesPost(options?: any): AxiosPromise<QuoteQuote> {
            return localVarFp.v1QuotesPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QuoteApi - object-oriented interface
 * @export
 * @class QuoteApi
 * @extends {BaseAPI}
 */
export class QuoteApi extends BaseAPI {
    /**
     * Get all existing Quotes.
     * @summary get all existing Quotes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteApi
     */
    public v1QuotesGet(options?: AxiosRequestConfig) {
        return QuoteApiFp(this.configuration).v1QuotesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accept Quote.
     * @summary accept Quote
     * @param {string} id Quote ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteApi
     */
    public v1QuotesIdAcceptPost(id: string, options?: AxiosRequestConfig) {
        return QuoteApiFp(this.configuration).v1QuotesIdAcceptPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel Quote.
     * @summary cancel Quote
     * @param {string} id Quote ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteApi
     */
    public v1QuotesIdCancelPost(id: string, options?: AxiosRequestConfig) {
        return QuoteApiFp(this.configuration).v1QuotesIdCancelPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete Quote by given ID.
     * @summary delete Quote by given ID
     * @param {string} id Quote ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteApi
     */
    public v1QuotesIdDelete(id: string, options?: AxiosRequestConfig) {
        return QuoteApiFp(this.configuration).v1QuotesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Finalize Quote.
     * @summary finalize Quote
     * @param {string} id Quote ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteApi
     */
    public v1QuotesIdFinalizePost(id: string, options?: AxiosRequestConfig) {
        return QuoteApiFp(this.configuration).v1QuotesIdFinalizePost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Quote by given ID or 404 error.
     * @summary get Quote by given ID or 404 error.
     * @param {string} id Quote ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteApi
     */
    public v1QuotesIdGet(id: string, options?: AxiosRequestConfig) {
        return QuoteApiFp(this.configuration).v1QuotesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Quote.
     * @summary update Quote
     * @param {string} id Quote ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteApi
     */
    public v1QuotesIdPost(id: string, options?: AxiosRequestConfig) {
        return QuoteApiFp(this.configuration).v1QuotesIdPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new Quote.
     * @summary create a new Quote
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuoteApi
     */
    public v1QuotesPost(options?: AxiosRequestConfig) {
        return QuoteApiFp(this.configuration).v1QuotesPost(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RefundApi - axios parameter creator
 * @export
 */
export const RefundApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all existing Refunds.
         * @summary get all existing Refunds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1RefundsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/refunds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel Refund.
         * @summary cancel Refund
         * @param {string} id Refund ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1RefundsIdCancelePost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1RefundsIdCancelePost', 'id', id)
            const localVarPath = `/v1/refunds/{id}/cancele`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Refund by given ID.
         * @summary delete Refund by given ID
         * @param {string} id Refund ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1RefundsIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1RefundsIdDelete', 'id', id)
            const localVarPath = `/v1/refunds/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Refund by given ID or 404 error.
         * @summary get Refund by given ID or 404 error.
         * @param {string} id Refund ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1RefundsIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1RefundsIdGet', 'id', id)
            const localVarPath = `/v1/refunds/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Refund.
         * @summary update Refund
         * @param {string} id Refund ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1RefundsIdPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1RefundsIdPost', 'id', id)
            const localVarPath = `/v1/refunds/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Refund.
         * @summary create a new Refund
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1RefundsPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/refunds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RefundApi - functional programming interface
 * @export
 */
export const RefundApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RefundApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all existing Refunds.
         * @summary get all existing Refunds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1RefundsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RefundRefund>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1RefundsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cancel Refund.
         * @summary cancel Refund
         * @param {string} id Refund ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1RefundsIdCancelePost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefundRefund>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1RefundsIdCancelePost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete Refund by given ID.
         * @summary delete Refund by given ID
         * @param {string} id Refund ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1RefundsIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1RefundsIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Refund by given ID or 404 error.
         * @summary get Refund by given ID or 404 error.
         * @param {string} id Refund ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1RefundsIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefundRefund>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1RefundsIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update Refund.
         * @summary update Refund
         * @param {string} id Refund ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1RefundsIdPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefundRefund>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1RefundsIdPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new Refund.
         * @summary create a new Refund
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1RefundsPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefundRefund>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1RefundsPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RefundApi - factory interface
 * @export
 */
export const RefundApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RefundApiFp(configuration)
    return {
        /**
         * Get all existing Refunds.
         * @summary get all existing Refunds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1RefundsGet(options?: any): AxiosPromise<Array<RefundRefund>> {
            return localVarFp.v1RefundsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel Refund.
         * @summary cancel Refund
         * @param {string} id Refund ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1RefundsIdCancelePost(id: string, options?: any): AxiosPromise<RefundRefund> {
            return localVarFp.v1RefundsIdCancelePost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete Refund by given ID.
         * @summary delete Refund by given ID
         * @param {string} id Refund ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1RefundsIdDelete(id: string, options?: any): AxiosPromise<string> {
            return localVarFp.v1RefundsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Refund by given ID or 404 error.
         * @summary get Refund by given ID or 404 error.
         * @param {string} id Refund ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1RefundsIdGet(id: string, options?: any): AxiosPromise<RefundRefund> {
            return localVarFp.v1RefundsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Refund.
         * @summary update Refund
         * @param {string} id Refund ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1RefundsIdPost(id: string, options?: any): AxiosPromise<RefundRefund> {
            return localVarFp.v1RefundsIdPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new Refund.
         * @summary create a new Refund
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1RefundsPost(options?: any): AxiosPromise<RefundRefund> {
            return localVarFp.v1RefundsPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RefundApi - object-oriented interface
 * @export
 * @class RefundApi
 * @extends {BaseAPI}
 */
export class RefundApi extends BaseAPI {
    /**
     * Get all existing Refunds.
     * @summary get all existing Refunds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefundApi
     */
    public v1RefundsGet(options?: AxiosRequestConfig) {
        return RefundApiFp(this.configuration).v1RefundsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel Refund.
     * @summary cancel Refund
     * @param {string} id Refund ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefundApi
     */
    public v1RefundsIdCancelePost(id: string, options?: AxiosRequestConfig) {
        return RefundApiFp(this.configuration).v1RefundsIdCancelePost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete Refund by given ID.
     * @summary delete Refund by given ID
     * @param {string} id Refund ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefundApi
     */
    public v1RefundsIdDelete(id: string, options?: AxiosRequestConfig) {
        return RefundApiFp(this.configuration).v1RefundsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Refund by given ID or 404 error.
     * @summary get Refund by given ID or 404 error.
     * @param {string} id Refund ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefundApi
     */
    public v1RefundsIdGet(id: string, options?: AxiosRequestConfig) {
        return RefundApiFp(this.configuration).v1RefundsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Refund.
     * @summary update Refund
     * @param {string} id Refund ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefundApi
     */
    public v1RefundsIdPost(id: string, options?: AxiosRequestConfig) {
        return RefundApiFp(this.configuration).v1RefundsIdPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new Refund.
     * @summary create a new Refund
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefundApi
     */
    public v1RefundsPost(options?: AxiosRequestConfig) {
        return RefundApiFp(this.configuration).v1RefundsPost(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SetupAttemptApi - axios parameter creator
 * @export
 */
export const SetupAttemptApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all existing SetupAttempts.
         * @summary get all existing SetupAttempts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SetupAttemptsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/setup_attempts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete SetupAttempt by given ID.
         * @summary delete SetupAttempt by given ID
         * @param {string} id SetupAttempt ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SetupAttemptsIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1SetupAttemptsIdDelete', 'id', id)
            const localVarPath = `/v1/setup_attempts/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get SetupAttempt by given ID or 404 error.
         * @summary get SetupAttempt by given ID or 404 error.
         * @param {string} id SetupAttempt ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SetupAttemptsIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1SetupAttemptsIdGet', 'id', id)
            const localVarPath = `/v1/setup_attempts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update SetupAttempt.
         * @summary update SetupAttempt
         * @param {string} id SetupAttempt ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SetupAttemptsIdPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1SetupAttemptsIdPost', 'id', id)
            const localVarPath = `/v1/setup_attempts/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new SetupAttempt.
         * @summary create a new SetupAttempt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SetupAttemptsPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/setup_attempts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SetupAttemptApi - functional programming interface
 * @export
 */
export const SetupAttemptApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SetupAttemptApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all existing SetupAttempts.
         * @summary get all existing SetupAttempts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SetupAttemptsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AttemptSetupAttempt>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SetupAttemptsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete SetupAttempt by given ID.
         * @summary delete SetupAttempt by given ID
         * @param {string} id SetupAttempt ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SetupAttemptsIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SetupAttemptsIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get SetupAttempt by given ID or 404 error.
         * @summary get SetupAttempt by given ID or 404 error.
         * @param {string} id SetupAttempt ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SetupAttemptsIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttemptSetupAttempt>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SetupAttemptsIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update SetupAttempt.
         * @summary update SetupAttempt
         * @param {string} id SetupAttempt ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SetupAttemptsIdPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttemptSetupAttempt>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SetupAttemptsIdPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new SetupAttempt.
         * @summary create a new SetupAttempt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SetupAttemptsPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttemptSetupAttempt>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SetupAttemptsPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SetupAttemptApi - factory interface
 * @export
 */
export const SetupAttemptApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SetupAttemptApiFp(configuration)
    return {
        /**
         * Get all existing SetupAttempts.
         * @summary get all existing SetupAttempts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SetupAttemptsGet(options?: any): AxiosPromise<Array<AttemptSetupAttempt>> {
            return localVarFp.v1SetupAttemptsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete SetupAttempt by given ID.
         * @summary delete SetupAttempt by given ID
         * @param {string} id SetupAttempt ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SetupAttemptsIdDelete(id: string, options?: any): AxiosPromise<string> {
            return localVarFp.v1SetupAttemptsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get SetupAttempt by given ID or 404 error.
         * @summary get SetupAttempt by given ID or 404 error.
         * @param {string} id SetupAttempt ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SetupAttemptsIdGet(id: string, options?: any): AxiosPromise<AttemptSetupAttempt> {
            return localVarFp.v1SetupAttemptsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update SetupAttempt.
         * @summary update SetupAttempt
         * @param {string} id SetupAttempt ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SetupAttemptsIdPost(id: string, options?: any): AxiosPromise<AttemptSetupAttempt> {
            return localVarFp.v1SetupAttemptsIdPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new SetupAttempt.
         * @summary create a new SetupAttempt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SetupAttemptsPost(options?: any): AxiosPromise<AttemptSetupAttempt> {
            return localVarFp.v1SetupAttemptsPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SetupAttemptApi - object-oriented interface
 * @export
 * @class SetupAttemptApi
 * @extends {BaseAPI}
 */
export class SetupAttemptApi extends BaseAPI {
    /**
     * Get all existing SetupAttempts.
     * @summary get all existing SetupAttempts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupAttemptApi
     */
    public v1SetupAttemptsGet(options?: AxiosRequestConfig) {
        return SetupAttemptApiFp(this.configuration).v1SetupAttemptsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete SetupAttempt by given ID.
     * @summary delete SetupAttempt by given ID
     * @param {string} id SetupAttempt ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupAttemptApi
     */
    public v1SetupAttemptsIdDelete(id: string, options?: AxiosRequestConfig) {
        return SetupAttemptApiFp(this.configuration).v1SetupAttemptsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get SetupAttempt by given ID or 404 error.
     * @summary get SetupAttempt by given ID or 404 error.
     * @param {string} id SetupAttempt ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupAttemptApi
     */
    public v1SetupAttemptsIdGet(id: string, options?: AxiosRequestConfig) {
        return SetupAttemptApiFp(this.configuration).v1SetupAttemptsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update SetupAttempt.
     * @summary update SetupAttempt
     * @param {string} id SetupAttempt ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupAttemptApi
     */
    public v1SetupAttemptsIdPost(id: string, options?: AxiosRequestConfig) {
        return SetupAttemptApiFp(this.configuration).v1SetupAttemptsIdPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new SetupAttempt.
     * @summary create a new SetupAttempt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupAttemptApi
     */
    public v1SetupAttemptsPost(options?: AxiosRequestConfig) {
        return SetupAttemptApiFp(this.configuration).v1SetupAttemptsPost(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SetupIntentApi - axios parameter creator
 * @export
 */
export const SetupIntentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all existing SetupIntents.
         * @summary get all existing SetupIntents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SetupIntentsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/setup_intents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel SetupIntent.
         * @summary cancel SetupIntent
         * @param {string} id SetupIntent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SetupIntentsIdCancelePost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1SetupIntentsIdCancelePost', 'id', id)
            const localVarPath = `/v1/setup_intents/{id}/cancele`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Confirm SetupIntent.
         * @summary confirm SetupIntent
         * @param {string} id SetupIntent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SetupIntentsIdConfirmPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1SetupIntentsIdConfirmPost', 'id', id)
            const localVarPath = `/v1/setup_intents/{id}/confirm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete SetupIntent by given ID.
         * @summary delete SetupIntent by given ID
         * @param {string} id SetupIntent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SetupIntentsIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1SetupIntentsIdDelete', 'id', id)
            const localVarPath = `/v1/setup_intents/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get SetupIntent by given ID or 404 error.
         * @summary get SetupIntent by given ID or 404 error.
         * @param {string} id SetupIntent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SetupIntentsIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1SetupIntentsIdGet', 'id', id)
            const localVarPath = `/v1/setup_intents/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update SetupIntent.
         * @summary update SetupIntent
         * @param {string} id SetupIntent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SetupIntentsIdPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1SetupIntentsIdPost', 'id', id)
            const localVarPath = `/v1/setup_intents/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new SetupIntent.
         * @summary create a new SetupIntent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SetupIntentsPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/setup_intents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SetupIntentApi - functional programming interface
 * @export
 */
export const SetupIntentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SetupIntentApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all existing SetupIntents.
         * @summary get all existing SetupIntents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SetupIntentsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IntentSetupIntent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SetupIntentsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cancel SetupIntent.
         * @summary cancel SetupIntent
         * @param {string} id SetupIntent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SetupIntentsIdCancelePost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntentSetupIntent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SetupIntentsIdCancelePost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Confirm SetupIntent.
         * @summary confirm SetupIntent
         * @param {string} id SetupIntent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SetupIntentsIdConfirmPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntentSetupIntent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SetupIntentsIdConfirmPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete SetupIntent by given ID.
         * @summary delete SetupIntent by given ID
         * @param {string} id SetupIntent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SetupIntentsIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SetupIntentsIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get SetupIntent by given ID or 404 error.
         * @summary get SetupIntent by given ID or 404 error.
         * @param {string} id SetupIntent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SetupIntentsIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntentSetupIntent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SetupIntentsIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update SetupIntent.
         * @summary update SetupIntent
         * @param {string} id SetupIntent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SetupIntentsIdPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntentSetupIntent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SetupIntentsIdPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new SetupIntent.
         * @summary create a new SetupIntent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SetupIntentsPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntentSetupIntent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SetupIntentsPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SetupIntentApi - factory interface
 * @export
 */
export const SetupIntentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SetupIntentApiFp(configuration)
    return {
        /**
         * Get all existing SetupIntents.
         * @summary get all existing SetupIntents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SetupIntentsGet(options?: any): AxiosPromise<Array<IntentSetupIntent>> {
            return localVarFp.v1SetupIntentsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel SetupIntent.
         * @summary cancel SetupIntent
         * @param {string} id SetupIntent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SetupIntentsIdCancelePost(id: string, options?: any): AxiosPromise<IntentSetupIntent> {
            return localVarFp.v1SetupIntentsIdCancelePost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Confirm SetupIntent.
         * @summary confirm SetupIntent
         * @param {string} id SetupIntent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SetupIntentsIdConfirmPost(id: string, options?: any): AxiosPromise<IntentSetupIntent> {
            return localVarFp.v1SetupIntentsIdConfirmPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete SetupIntent by given ID.
         * @summary delete SetupIntent by given ID
         * @param {string} id SetupIntent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SetupIntentsIdDelete(id: string, options?: any): AxiosPromise<string> {
            return localVarFp.v1SetupIntentsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get SetupIntent by given ID or 404 error.
         * @summary get SetupIntent by given ID or 404 error.
         * @param {string} id SetupIntent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SetupIntentsIdGet(id: string, options?: any): AxiosPromise<IntentSetupIntent> {
            return localVarFp.v1SetupIntentsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update SetupIntent.
         * @summary update SetupIntent
         * @param {string} id SetupIntent ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SetupIntentsIdPost(id: string, options?: any): AxiosPromise<IntentSetupIntent> {
            return localVarFp.v1SetupIntentsIdPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new SetupIntent.
         * @summary create a new SetupIntent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SetupIntentsPost(options?: any): AxiosPromise<IntentSetupIntent> {
            return localVarFp.v1SetupIntentsPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SetupIntentApi - object-oriented interface
 * @export
 * @class SetupIntentApi
 * @extends {BaseAPI}
 */
export class SetupIntentApi extends BaseAPI {
    /**
     * Get all existing SetupIntents.
     * @summary get all existing SetupIntents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupIntentApi
     */
    public v1SetupIntentsGet(options?: AxiosRequestConfig) {
        return SetupIntentApiFp(this.configuration).v1SetupIntentsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel SetupIntent.
     * @summary cancel SetupIntent
     * @param {string} id SetupIntent ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupIntentApi
     */
    public v1SetupIntentsIdCancelePost(id: string, options?: AxiosRequestConfig) {
        return SetupIntentApiFp(this.configuration).v1SetupIntentsIdCancelePost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Confirm SetupIntent.
     * @summary confirm SetupIntent
     * @param {string} id SetupIntent ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupIntentApi
     */
    public v1SetupIntentsIdConfirmPost(id: string, options?: AxiosRequestConfig) {
        return SetupIntentApiFp(this.configuration).v1SetupIntentsIdConfirmPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete SetupIntent by given ID.
     * @summary delete SetupIntent by given ID
     * @param {string} id SetupIntent ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupIntentApi
     */
    public v1SetupIntentsIdDelete(id: string, options?: AxiosRequestConfig) {
        return SetupIntentApiFp(this.configuration).v1SetupIntentsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get SetupIntent by given ID or 404 error.
     * @summary get SetupIntent by given ID or 404 error.
     * @param {string} id SetupIntent ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupIntentApi
     */
    public v1SetupIntentsIdGet(id: string, options?: AxiosRequestConfig) {
        return SetupIntentApiFp(this.configuration).v1SetupIntentsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update SetupIntent.
     * @summary update SetupIntent
     * @param {string} id SetupIntent ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupIntentApi
     */
    public v1SetupIntentsIdPost(id: string, options?: AxiosRequestConfig) {
        return SetupIntentApiFp(this.configuration).v1SetupIntentsIdPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new SetupIntent.
     * @summary create a new SetupIntent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetupIntentApi
     */
    public v1SetupIntentsPost(options?: AxiosRequestConfig) {
        return SetupIntentApiFp(this.configuration).v1SetupIntentsPost(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SourceApi - axios parameter creator
 * @export
 */
export const SourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * dettaching Source from Customer by given ID.
         * @summary dettaching Source from Customer by given ID
         * @param {string} id Source ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersIdSourcesIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CustomersIdSourcesIdDelete', 'id', id)
            const localVarPath = `/v1/customers/{id}/sources/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Attaching Source to Customer by given ID.
         * @summary attaching Source to Customer by given ID
         * @param {string} id Source ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersIdSourcesPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1CustomersIdSourcesPost', 'id', id)
            const localVarPath = `/v1/customers/{id}/sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all existing Sources.
         * @summary get all existing Sources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourcesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Source by given ID.
         * @summary delete Source by given ID
         * @param {string} id Source ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourcesIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1SourcesIdDelete', 'id', id)
            const localVarPath = `/v1/sources/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Source by given ID or 404 error.
         * @summary get Source by given ID or 404 error.
         * @param {string} id Source ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourcesIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1SourcesIdGet', 'id', id)
            const localVarPath = `/v1/sources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Source.
         * @summary update Source
         * @param {string} id Source ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourcesIdPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1SourcesIdPost', 'id', id)
            const localVarPath = `/v1/sources/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Source.
         * @summary create a new Source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourcesPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SourceApi - functional programming interface
 * @export
 */
export const SourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SourceApiAxiosParamCreator(configuration)
    return {
        /**
         * dettaching Source from Customer by given ID.
         * @summary dettaching Source from Customer by given ID
         * @param {string} id Source ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CustomersIdSourcesIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CustomersIdSourcesIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Attaching Source to Customer by given ID.
         * @summary attaching Source to Customer by given ID
         * @param {string} id Source ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1CustomersIdSourcesPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1CustomersIdSourcesPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all existing Sources.
         * @summary get all existing Sources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SourcesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SourceSource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SourcesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete Source by given ID.
         * @summary delete Source by given ID
         * @param {string} id Source ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SourcesIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SourcesIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Source by given ID or 404 error.
         * @summary get Source by given ID or 404 error.
         * @param {string} id Source ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SourcesIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceSource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SourcesIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update Source.
         * @summary update Source
         * @param {string} id Source ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SourcesIdPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceSource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SourcesIdPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new Source.
         * @summary create a new Source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SourcesPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceSource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SourcesPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SourceApi - factory interface
 * @export
 */
export const SourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SourceApiFp(configuration)
    return {
        /**
         * dettaching Source from Customer by given ID.
         * @summary dettaching Source from Customer by given ID
         * @param {string} id Source ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersIdSourcesIdDelete(id: string, options?: any): AxiosPromise<string> {
            return localVarFp.v1CustomersIdSourcesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Attaching Source to Customer by given ID.
         * @summary attaching Source to Customer by given ID
         * @param {string} id Source ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1CustomersIdSourcesPost(id: string, options?: any): AxiosPromise<string> {
            return localVarFp.v1CustomersIdSourcesPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all existing Sources.
         * @summary get all existing Sources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourcesGet(options?: any): AxiosPromise<Array<SourceSource>> {
            return localVarFp.v1SourcesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete Source by given ID.
         * @summary delete Source by given ID
         * @param {string} id Source ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourcesIdDelete(id: string, options?: any): AxiosPromise<string> {
            return localVarFp.v1SourcesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Source by given ID or 404 error.
         * @summary get Source by given ID or 404 error.
         * @param {string} id Source ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourcesIdGet(id: string, options?: any): AxiosPromise<SourceSource> {
            return localVarFp.v1SourcesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Source.
         * @summary update Source
         * @param {string} id Source ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourcesIdPost(id: string, options?: any): AxiosPromise<SourceSource> {
            return localVarFp.v1SourcesIdPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new Source.
         * @summary create a new Source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourcesPost(options?: any): AxiosPromise<SourceSource> {
            return localVarFp.v1SourcesPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SourceApi - object-oriented interface
 * @export
 * @class SourceApi
 * @extends {BaseAPI}
 */
export class SourceApi extends BaseAPI {
    /**
     * dettaching Source from Customer by given ID.
     * @summary dettaching Source from Customer by given ID
     * @param {string} id Source ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceApi
     */
    public v1CustomersIdSourcesIdDelete(id: string, options?: AxiosRequestConfig) {
        return SourceApiFp(this.configuration).v1CustomersIdSourcesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Attaching Source to Customer by given ID.
     * @summary attaching Source to Customer by given ID
     * @param {string} id Source ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceApi
     */
    public v1CustomersIdSourcesPost(id: string, options?: AxiosRequestConfig) {
        return SourceApiFp(this.configuration).v1CustomersIdSourcesPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all existing Sources.
     * @summary get all existing Sources
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceApi
     */
    public v1SourcesGet(options?: AxiosRequestConfig) {
        return SourceApiFp(this.configuration).v1SourcesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete Source by given ID.
     * @summary delete Source by given ID
     * @param {string} id Source ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceApi
     */
    public v1SourcesIdDelete(id: string, options?: AxiosRequestConfig) {
        return SourceApiFp(this.configuration).v1SourcesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Source by given ID or 404 error.
     * @summary get Source by given ID or 404 error.
     * @param {string} id Source ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceApi
     */
    public v1SourcesIdGet(id: string, options?: AxiosRequestConfig) {
        return SourceApiFp(this.configuration).v1SourcesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Source.
     * @summary update Source
     * @param {string} id Source ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceApi
     */
    public v1SourcesIdPost(id: string, options?: AxiosRequestConfig) {
        return SourceApiFp(this.configuration).v1SourcesIdPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new Source.
     * @summary create a new Source
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceApi
     */
    public v1SourcesPost(options?: AxiosRequestConfig) {
        return SourceApiFp(this.configuration).v1SourcesPost(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SubscriptionApi - axios parameter creator
 * @export
 */
export const SubscriptionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all existing Subscriptions.
         * @summary get all existing Subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubscriptionsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Subscription by given ID.
         * @summary delete Subscription by given ID
         * @param {string} id Subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubscriptionsIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1SubscriptionsIdDelete', 'id', id)
            const localVarPath = `/v1/subscriptions/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Subscription by given ID or 404 error.
         * @summary get Subscription by given ID or 404 error.
         * @param {string} id Subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubscriptionsIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1SubscriptionsIdGet', 'id', id)
            const localVarPath = `/v1/subscriptions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Subscription.
         * @summary update Subscription
         * @param {string} id Subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubscriptionsIdPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1SubscriptionsIdPost', 'id', id)
            const localVarPath = `/v1/subscriptions/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Subscription.
         * @summary create a new Subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubscriptionsPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriptionApi - functional programming interface
 * @export
 */
export const SubscriptionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubscriptionApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all existing Subscriptions.
         * @summary get all existing Subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SubscriptionsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SubscriptionSubscription>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SubscriptionsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete Subscription by given ID.
         * @summary delete Subscription by given ID
         * @param {string} id Subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SubscriptionsIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SubscriptionsIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Subscription by given ID or 404 error.
         * @summary get Subscription by given ID or 404 error.
         * @param {string} id Subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SubscriptionsIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionSubscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SubscriptionsIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update Subscription.
         * @summary update Subscription
         * @param {string} id Subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SubscriptionsIdPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionSubscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SubscriptionsIdPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new Subscription.
         * @summary create a new Subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SubscriptionsPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionSubscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SubscriptionsPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SubscriptionApi - factory interface
 * @export
 */
export const SubscriptionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubscriptionApiFp(configuration)
    return {
        /**
         * Get all existing Subscriptions.
         * @summary get all existing Subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubscriptionsGet(options?: any): AxiosPromise<Array<SubscriptionSubscription>> {
            return localVarFp.v1SubscriptionsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete Subscription by given ID.
         * @summary delete Subscription by given ID
         * @param {string} id Subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubscriptionsIdDelete(id: string, options?: any): AxiosPromise<string> {
            return localVarFp.v1SubscriptionsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Subscription by given ID or 404 error.
         * @summary get Subscription by given ID or 404 error.
         * @param {string} id Subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubscriptionsIdGet(id: string, options?: any): AxiosPromise<SubscriptionSubscription> {
            return localVarFp.v1SubscriptionsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Subscription.
         * @summary update Subscription
         * @param {string} id Subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubscriptionsIdPost(id: string, options?: any): AxiosPromise<SubscriptionSubscription> {
            return localVarFp.v1SubscriptionsIdPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new Subscription.
         * @summary create a new Subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubscriptionsPost(options?: any): AxiosPromise<SubscriptionSubscription> {
            return localVarFp.v1SubscriptionsPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubscriptionApi - object-oriented interface
 * @export
 * @class SubscriptionApi
 * @extends {BaseAPI}
 */
export class SubscriptionApi extends BaseAPI {
    /**
     * Get all existing Subscriptions.
     * @summary get all existing Subscriptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public v1SubscriptionsGet(options?: AxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).v1SubscriptionsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete Subscription by given ID.
     * @summary delete Subscription by given ID
     * @param {string} id Subscription ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public v1SubscriptionsIdDelete(id: string, options?: AxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).v1SubscriptionsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Subscription by given ID or 404 error.
     * @summary get Subscription by given ID or 404 error.
     * @param {string} id Subscription ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public v1SubscriptionsIdGet(id: string, options?: AxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).v1SubscriptionsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Subscription.
     * @summary update Subscription
     * @param {string} id Subscription ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public v1SubscriptionsIdPost(id: string, options?: AxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).v1SubscriptionsIdPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new Subscription.
     * @summary create a new Subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public v1SubscriptionsPost(options?: AxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).v1SubscriptionsPost(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SubscriptionItemApi - axios parameter creator
 * @export
 */
export const SubscriptionItemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all existing SubscriptionItems.
         * @summary get all existing SubscriptionItems
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubscriptionItemsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/subscription_items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete SubscriptionItem by given ID.
         * @summary delete SubscriptionItem by given ID
         * @param {string} id SubscriptionItem ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubscriptionItemsIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1SubscriptionItemsIdDelete', 'id', id)
            const localVarPath = `/v1/subscription_items/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get SubscriptionItem by given ID or 404 error.
         * @summary get SubscriptionItem by given ID or 404 error.
         * @param {string} id SubscriptionItem ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubscriptionItemsIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1SubscriptionItemsIdGet', 'id', id)
            const localVarPath = `/v1/subscription_items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update SubscriptionItem.
         * @summary update SubscriptionItem
         * @param {string} id SubscriptionItem ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubscriptionItemsIdPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1SubscriptionItemsIdPost', 'id', id)
            const localVarPath = `/v1/subscription_items/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new SubscriptionItem.
         * @summary create a new SubscriptionItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubscriptionItemsPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/subscription_items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriptionItemApi - functional programming interface
 * @export
 */
export const SubscriptionItemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubscriptionItemApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all existing SubscriptionItems.
         * @summary get all existing SubscriptionItems
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SubscriptionItemsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SubscriptionItemSubscriptionItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SubscriptionItemsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete SubscriptionItem by given ID.
         * @summary delete SubscriptionItem by given ID
         * @param {string} id SubscriptionItem ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SubscriptionItemsIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SubscriptionItemsIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get SubscriptionItem by given ID or 404 error.
         * @summary get SubscriptionItem by given ID or 404 error.
         * @param {string} id SubscriptionItem ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SubscriptionItemsIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionItemSubscriptionItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SubscriptionItemsIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update SubscriptionItem.
         * @summary update SubscriptionItem
         * @param {string} id SubscriptionItem ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SubscriptionItemsIdPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionItemSubscriptionItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SubscriptionItemsIdPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new SubscriptionItem.
         * @summary create a new SubscriptionItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SubscriptionItemsPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionItemSubscriptionItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SubscriptionItemsPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SubscriptionItemApi - factory interface
 * @export
 */
export const SubscriptionItemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubscriptionItemApiFp(configuration)
    return {
        /**
         * Get all existing SubscriptionItems.
         * @summary get all existing SubscriptionItems
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubscriptionItemsGet(options?: any): AxiosPromise<Array<SubscriptionItemSubscriptionItem>> {
            return localVarFp.v1SubscriptionItemsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete SubscriptionItem by given ID.
         * @summary delete SubscriptionItem by given ID
         * @param {string} id SubscriptionItem ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubscriptionItemsIdDelete(id: string, options?: any): AxiosPromise<string> {
            return localVarFp.v1SubscriptionItemsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get SubscriptionItem by given ID or 404 error.
         * @summary get SubscriptionItem by given ID or 404 error.
         * @param {string} id SubscriptionItem ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubscriptionItemsIdGet(id: string, options?: any): AxiosPromise<SubscriptionItemSubscriptionItem> {
            return localVarFp.v1SubscriptionItemsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update SubscriptionItem.
         * @summary update SubscriptionItem
         * @param {string} id SubscriptionItem ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubscriptionItemsIdPost(id: string, options?: any): AxiosPromise<SubscriptionItemSubscriptionItem> {
            return localVarFp.v1SubscriptionItemsIdPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new SubscriptionItem.
         * @summary create a new SubscriptionItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubscriptionItemsPost(options?: any): AxiosPromise<SubscriptionItemSubscriptionItem> {
            return localVarFp.v1SubscriptionItemsPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubscriptionItemApi - object-oriented interface
 * @export
 * @class SubscriptionItemApi
 * @extends {BaseAPI}
 */
export class SubscriptionItemApi extends BaseAPI {
    /**
     * Get all existing SubscriptionItems.
     * @summary get all existing SubscriptionItems
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionItemApi
     */
    public v1SubscriptionItemsGet(options?: AxiosRequestConfig) {
        return SubscriptionItemApiFp(this.configuration).v1SubscriptionItemsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete SubscriptionItem by given ID.
     * @summary delete SubscriptionItem by given ID
     * @param {string} id SubscriptionItem ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionItemApi
     */
    public v1SubscriptionItemsIdDelete(id: string, options?: AxiosRequestConfig) {
        return SubscriptionItemApiFp(this.configuration).v1SubscriptionItemsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get SubscriptionItem by given ID or 404 error.
     * @summary get SubscriptionItem by given ID or 404 error.
     * @param {string} id SubscriptionItem ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionItemApi
     */
    public v1SubscriptionItemsIdGet(id: string, options?: AxiosRequestConfig) {
        return SubscriptionItemApiFp(this.configuration).v1SubscriptionItemsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update SubscriptionItem.
     * @summary update SubscriptionItem
     * @param {string} id SubscriptionItem ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionItemApi
     */
    public v1SubscriptionItemsIdPost(id: string, options?: AxiosRequestConfig) {
        return SubscriptionItemApiFp(this.configuration).v1SubscriptionItemsIdPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new SubscriptionItem.
     * @summary create a new SubscriptionItem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionItemApi
     */
    public v1SubscriptionItemsPost(options?: AxiosRequestConfig) {
        return SubscriptionItemApiFp(this.configuration).v1SubscriptionItemsPost(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SubscriptionScheduleApi - axios parameter creator
 * @export
 */
export const SubscriptionScheduleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all existing SubscriptionSchedules.
         * @summary get all existing SubscriptionSchedules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubscriptionSchedulesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/subscription_schedules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel SubscriptionSchedule.
         * @summary cancel SubscriptionSchedule
         * @param {string} id SubscriptionSchedule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubscriptionSchedulesIdCancelePost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1SubscriptionSchedulesIdCancelePost', 'id', id)
            const localVarPath = `/v1/subscription_schedules/{id}/cancele`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete SubscriptionSchedule by given ID.
         * @summary delete SubscriptionSchedule by given ID
         * @param {string} id SubscriptionSchedule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubscriptionSchedulesIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1SubscriptionSchedulesIdDelete', 'id', id)
            const localVarPath = `/v1/subscription_schedules/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get SubscriptionSchedule by given ID or 404 error.
         * @summary get SubscriptionSchedule by given ID or 404 error.
         * @param {string} id SubscriptionSchedule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubscriptionSchedulesIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1SubscriptionSchedulesIdGet', 'id', id)
            const localVarPath = `/v1/subscription_schedules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update SubscriptionSchedule.
         * @summary update SubscriptionSchedule
         * @param {string} id SubscriptionSchedule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubscriptionSchedulesIdPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1SubscriptionSchedulesIdPost', 'id', id)
            const localVarPath = `/v1/subscription_schedules/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Release SubscriptionSchedule.
         * @summary release SubscriptionSchedule
         * @param {string} id SubscriptionSchedule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubscriptionSchedulesIdReleasePost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1SubscriptionSchedulesIdReleasePost', 'id', id)
            const localVarPath = `/v1/subscription_schedules/{id}/release`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(id, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new SubscriptionSchedule.
         * @summary create a new SubscriptionSchedule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubscriptionSchedulesPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/subscription_schedules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriptionScheduleApi - functional programming interface
 * @export
 */
export const SubscriptionScheduleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubscriptionScheduleApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all existing SubscriptionSchedules.
         * @summary get all existing SubscriptionSchedules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SubscriptionSchedulesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SubscriptionScheduleSubscriptionSchedule>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SubscriptionSchedulesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cancel SubscriptionSchedule.
         * @summary cancel SubscriptionSchedule
         * @param {string} id SubscriptionSchedule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SubscriptionSchedulesIdCancelePost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionScheduleSubscriptionSchedule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SubscriptionSchedulesIdCancelePost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete SubscriptionSchedule by given ID.
         * @summary delete SubscriptionSchedule by given ID
         * @param {string} id SubscriptionSchedule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SubscriptionSchedulesIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SubscriptionSchedulesIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get SubscriptionSchedule by given ID or 404 error.
         * @summary get SubscriptionSchedule by given ID or 404 error.
         * @param {string} id SubscriptionSchedule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SubscriptionSchedulesIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionScheduleSubscriptionSchedule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SubscriptionSchedulesIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update SubscriptionSchedule.
         * @summary update SubscriptionSchedule
         * @param {string} id SubscriptionSchedule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SubscriptionSchedulesIdPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionScheduleSubscriptionSchedule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SubscriptionSchedulesIdPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Release SubscriptionSchedule.
         * @summary release SubscriptionSchedule
         * @param {string} id SubscriptionSchedule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SubscriptionSchedulesIdReleasePost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionScheduleSubscriptionSchedule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SubscriptionSchedulesIdReleasePost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new SubscriptionSchedule.
         * @summary create a new SubscriptionSchedule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SubscriptionSchedulesPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionScheduleSubscriptionSchedule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SubscriptionSchedulesPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SubscriptionScheduleApi - factory interface
 * @export
 */
export const SubscriptionScheduleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubscriptionScheduleApiFp(configuration)
    return {
        /**
         * Get all existing SubscriptionSchedules.
         * @summary get all existing SubscriptionSchedules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubscriptionSchedulesGet(options?: any): AxiosPromise<Array<SubscriptionScheduleSubscriptionSchedule>> {
            return localVarFp.v1SubscriptionSchedulesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel SubscriptionSchedule.
         * @summary cancel SubscriptionSchedule
         * @param {string} id SubscriptionSchedule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubscriptionSchedulesIdCancelePost(id: string, options?: any): AxiosPromise<SubscriptionScheduleSubscriptionSchedule> {
            return localVarFp.v1SubscriptionSchedulesIdCancelePost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete SubscriptionSchedule by given ID.
         * @summary delete SubscriptionSchedule by given ID
         * @param {string} id SubscriptionSchedule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubscriptionSchedulesIdDelete(id: string, options?: any): AxiosPromise<string> {
            return localVarFp.v1SubscriptionSchedulesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get SubscriptionSchedule by given ID or 404 error.
         * @summary get SubscriptionSchedule by given ID or 404 error.
         * @param {string} id SubscriptionSchedule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubscriptionSchedulesIdGet(id: string, options?: any): AxiosPromise<SubscriptionScheduleSubscriptionSchedule> {
            return localVarFp.v1SubscriptionSchedulesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update SubscriptionSchedule.
         * @summary update SubscriptionSchedule
         * @param {string} id SubscriptionSchedule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubscriptionSchedulesIdPost(id: string, options?: any): AxiosPromise<SubscriptionScheduleSubscriptionSchedule> {
            return localVarFp.v1SubscriptionSchedulesIdPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Release SubscriptionSchedule.
         * @summary release SubscriptionSchedule
         * @param {string} id SubscriptionSchedule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubscriptionSchedulesIdReleasePost(id: string, options?: any): AxiosPromise<SubscriptionScheduleSubscriptionSchedule> {
            return localVarFp.v1SubscriptionSchedulesIdReleasePost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new SubscriptionSchedule.
         * @summary create a new SubscriptionSchedule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubscriptionSchedulesPost(options?: any): AxiosPromise<SubscriptionScheduleSubscriptionSchedule> {
            return localVarFp.v1SubscriptionSchedulesPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubscriptionScheduleApi - object-oriented interface
 * @export
 * @class SubscriptionScheduleApi
 * @extends {BaseAPI}
 */
export class SubscriptionScheduleApi extends BaseAPI {
    /**
     * Get all existing SubscriptionSchedules.
     * @summary get all existing SubscriptionSchedules
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionScheduleApi
     */
    public v1SubscriptionSchedulesGet(options?: AxiosRequestConfig) {
        return SubscriptionScheduleApiFp(this.configuration).v1SubscriptionSchedulesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel SubscriptionSchedule.
     * @summary cancel SubscriptionSchedule
     * @param {string} id SubscriptionSchedule ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionScheduleApi
     */
    public v1SubscriptionSchedulesIdCancelePost(id: string, options?: AxiosRequestConfig) {
        return SubscriptionScheduleApiFp(this.configuration).v1SubscriptionSchedulesIdCancelePost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete SubscriptionSchedule by given ID.
     * @summary delete SubscriptionSchedule by given ID
     * @param {string} id SubscriptionSchedule ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionScheduleApi
     */
    public v1SubscriptionSchedulesIdDelete(id: string, options?: AxiosRequestConfig) {
        return SubscriptionScheduleApiFp(this.configuration).v1SubscriptionSchedulesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get SubscriptionSchedule by given ID or 404 error.
     * @summary get SubscriptionSchedule by given ID or 404 error.
     * @param {string} id SubscriptionSchedule ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionScheduleApi
     */
    public v1SubscriptionSchedulesIdGet(id: string, options?: AxiosRequestConfig) {
        return SubscriptionScheduleApiFp(this.configuration).v1SubscriptionSchedulesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update SubscriptionSchedule.
     * @summary update SubscriptionSchedule
     * @param {string} id SubscriptionSchedule ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionScheduleApi
     */
    public v1SubscriptionSchedulesIdPost(id: string, options?: AxiosRequestConfig) {
        return SubscriptionScheduleApiFp(this.configuration).v1SubscriptionSchedulesIdPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Release SubscriptionSchedule.
     * @summary release SubscriptionSchedule
     * @param {string} id SubscriptionSchedule ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionScheduleApi
     */
    public v1SubscriptionSchedulesIdReleasePost(id: string, options?: AxiosRequestConfig) {
        return SubscriptionScheduleApiFp(this.configuration).v1SubscriptionSchedulesIdReleasePost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new SubscriptionSchedule.
     * @summary create a new SubscriptionSchedule
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionScheduleApi
     */
    public v1SubscriptionSchedulesPost(options?: AxiosRequestConfig) {
        return SubscriptionScheduleApiFp(this.configuration).v1SubscriptionSchedulesPost(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsageRecordApi - axios parameter creator
 * @export
 */
export const UsageRecordApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all existing UsageRecords.
         * @summary get all existing UsageRecords
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubscriptionItemsIdUsageRecordSummariesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/subscription_items/{id}/usage_record_summaries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get UsageRecord by given ID or 404 error.
         * @summary get UsageRecord by given ID or 404 error.
         * @param {string} id SubscriptionItem ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubscriptionItemsIdUsageRecordsGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1SubscriptionItemsIdUsageRecordsGet', 'id', id)
            const localVarPath = `/v1/subscription_items/{id}/usage_records`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete UsageRecord by given ID.
         * @summary delete UsageRecord by given ID
         * @param {string} id SubscriptionItem ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsageRecordIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1UsageRecordIdDelete', 'id', id)
            const localVarPath = `/v1/usage_record/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update UsageRecord.
         * @summary update UsageRecord
         * @param {string} id SubscriptionItem ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsageRecordIdPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v1UsageRecordIdPost', 'id', id)
            const localVarPath = `/v1/usage_record/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new UsageRecord.
         * @summary create a new UsageRecord
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsageRecordPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/usage_record`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsageRecordApi - functional programming interface
 * @export
 */
export const UsageRecordApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsageRecordApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all existing UsageRecords.
         * @summary get all existing UsageRecords
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SubscriptionItemsIdUsageRecordSummariesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UsageRecordUsageRecord>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SubscriptionItemsIdUsageRecordSummariesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get UsageRecord by given ID or 404 error.
         * @summary get UsageRecord by given ID or 404 error.
         * @param {string} id SubscriptionItem ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1SubscriptionItemsIdUsageRecordsGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageRecordUsageRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1SubscriptionItemsIdUsageRecordsGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete UsageRecord by given ID.
         * @summary delete UsageRecord by given ID
         * @param {string} id SubscriptionItem ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsageRecordIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsageRecordIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update UsageRecord.
         * @summary update UsageRecord
         * @param {string} id SubscriptionItem ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsageRecordIdPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageRecordUsageRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsageRecordIdPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new UsageRecord.
         * @summary create a new UsageRecord
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1UsageRecordPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageRecordUsageRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsageRecordPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsageRecordApi - factory interface
 * @export
 */
export const UsageRecordApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsageRecordApiFp(configuration)
    return {
        /**
         * Get all existing UsageRecords.
         * @summary get all existing UsageRecords
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubscriptionItemsIdUsageRecordSummariesGet(options?: any): AxiosPromise<Array<UsageRecordUsageRecord>> {
            return localVarFp.v1SubscriptionItemsIdUsageRecordSummariesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get UsageRecord by given ID or 404 error.
         * @summary get UsageRecord by given ID or 404 error.
         * @param {string} id SubscriptionItem ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SubscriptionItemsIdUsageRecordsGet(id: string, options?: any): AxiosPromise<UsageRecordUsageRecord> {
            return localVarFp.v1SubscriptionItemsIdUsageRecordsGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete UsageRecord by given ID.
         * @summary delete UsageRecord by given ID
         * @param {string} id SubscriptionItem ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsageRecordIdDelete(id: string, options?: any): AxiosPromise<string> {
            return localVarFp.v1UsageRecordIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update UsageRecord.
         * @summary update UsageRecord
         * @param {string} id SubscriptionItem ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsageRecordIdPost(id: string, options?: any): AxiosPromise<UsageRecordUsageRecord> {
            return localVarFp.v1UsageRecordIdPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new UsageRecord.
         * @summary create a new UsageRecord
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UsageRecordPost(options?: any): AxiosPromise<UsageRecordUsageRecord> {
            return localVarFp.v1UsageRecordPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsageRecordApi - object-oriented interface
 * @export
 * @class UsageRecordApi
 * @extends {BaseAPI}
 */
export class UsageRecordApi extends BaseAPI {
    /**
     * Get all existing UsageRecords.
     * @summary get all existing UsageRecords
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageRecordApi
     */
    public v1SubscriptionItemsIdUsageRecordSummariesGet(options?: AxiosRequestConfig) {
        return UsageRecordApiFp(this.configuration).v1SubscriptionItemsIdUsageRecordSummariesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get UsageRecord by given ID or 404 error.
     * @summary get UsageRecord by given ID or 404 error.
     * @param {string} id SubscriptionItem ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageRecordApi
     */
    public v1SubscriptionItemsIdUsageRecordsGet(id: string, options?: AxiosRequestConfig) {
        return UsageRecordApiFp(this.configuration).v1SubscriptionItemsIdUsageRecordsGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete UsageRecord by given ID.
     * @summary delete UsageRecord by given ID
     * @param {string} id SubscriptionItem ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageRecordApi
     */
    public v1UsageRecordIdDelete(id: string, options?: AxiosRequestConfig) {
        return UsageRecordApiFp(this.configuration).v1UsageRecordIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update UsageRecord.
     * @summary update UsageRecord
     * @param {string} id SubscriptionItem ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageRecordApi
     */
    public v1UsageRecordIdPost(id: string, options?: AxiosRequestConfig) {
        return UsageRecordApiFp(this.configuration).v1UsageRecordIdPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new UsageRecord.
     * @summary create a new UsageRecord
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageRecordApi
     */
    public v1UsageRecordPost(options?: AxiosRequestConfig) {
        return UsageRecordApiFp(this.configuration).v1UsageRecordPost(options).then((request) => request(this.axios, this.basePath));
    }
}


